[TOC]

## 文本序列类型 --- [`str`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str)

在 Python 中处理文本数据是使用 [`str`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 对象，也称为 *字符串*。 字符串是由 Unicode 码位构成的不可变 [序列](https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq)。 字符串字面值有多种不同的写法：

- 单引号: `'允许包含有 "双" 引号'`
- 双引号: `"允许包含有 '单' 引号"`。
- 三重引号: `'''三重单引号'''`, `"""三重双引号"""`

使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。

作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，`("spam " "eggs") == "spam eggs"`。

请参阅 [字符串与字节串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#strings) 有解有关不同字符串字面值的更多信息，包括所支持的转义序列，以及使用 `r` ("raw") 前缀来禁用大多数转义序列的处理。

字符串也可以通过使用 [`str`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 构造器从其他对象创建。

由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 *s*, `s[0] == s[0:1]`。

不存在可变的字符串类型，但是 [`str.join()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.join) 或 [`io.StringIO`](https://docs.python.org/zh-cn/3/library/io.html#io.StringIO) 可以被被用来根据多个片段高效率地构建字符串。

*在 3.3 版更改:* 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 `u` 前缀。 它对字符串字面值的含义没有影响，并且不能与 `r` 前缀同时出现。



- *class* `str`(*object=''*)

- *class* `str`(*object=b''*, *encoding='utf-8'*, *errors='strict'*)

  返回 *object* 的 [字符串](https://docs.python.org/zh-cn/3/library/stdtypes.html#textseq) 版本。 如果未提供 *object* 则返回空字符串。 在其他情况下 `str()` 的行为取决于 *encoding* 或 *errors* 是否有给出，具体见下。如果 *encoding* 或 *errors* 均未给出，`str(object)` 返回 [`object.__str__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__)，这是 *object* 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 *object* 没有 [`__str__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__) 方法，则 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 将回退为返回 [`repr(object)`](https://docs.python.org/zh-cn/3/library/functions.html#repr)。如果 *encoding* 或 *errors* 至少给出其中之一，则 *object* 应该是一个 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) (例如 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 或 [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray))。 在此情况下，如果 *object* 是一个 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) (或 [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray)) 对象，则 `str(bytes, encoding, errors)` 等价于 [`bytes.decode(encoding, errors)`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.decode)。 否则的话，会在调用 [`bytes.decode()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.decode) 之前获取缓冲区对象下层的 bytes 对象。 请参阅 [二进制序列类型 --- bytes, bytearray, memoryview](https://docs.python.org/zh-cn/3/library/stdtypes.html#binaryseq) 与 [缓冲协议](https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects) 了解有关缓冲区对象的信息。将一个 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象传入 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 而不给出 *encoding* 或 *errors* 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 [`-b`](https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-b) 命令行选项）。 例如:>>>`>>> str(b'Zoot!') "b'Zoot!'" `有关 `str` 类及其方法的更多信息，请参阅下面的 [文本序列类型 --- str](https://docs.python.org/zh-cn/3/library/stdtypes.html#textseq) 和 [字符串的方法](https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods) 小节。 要输出格式化字符串，请参阅 [格式字符串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings) 和 [格式字符串语法](https://docs.python.org/zh-cn/3/library/string.html#formatstrings) 小节。 此外还可以参阅 [文本处理服务](https://docs.python.org/zh-cn/3/library/text.html#stringservices) 小节。



### 字符串的方法

字符串实现了所有 [一般](https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq-common) 序列的操作，还额外提供了以下列出的一些附加方法。

字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 [`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format), [格式字符串语法](https://docs.python.org/zh-cn/3/library/string.html#formatstrings) 和 [自定义字符串格式化](https://docs.python.org/zh-cn/3/library/string.html#string-formatting)) 而另一种是基于 C `printf` 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 ([printf 风格的字符串格式化](https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting))。

标准库的 [文本处理服务](https://docs.python.org/zh-cn/3/library/text.html#textservices) 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 [`re`](https://docs.python.org/zh-cn/3/library/re.html#module-re) 模块中的正则表达式支持）。

- `str.``capitalize`()

  返回原字符串的副本，其首个字符大写，其余为小写。*在 3.8 版更改:* 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。

- `str.``casefold`()

  返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 `'ß'` 相当于 `"ss"`。 由于它已经是小写了，[`lower()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.lower) 不会对 `'ß'` 做任何改变；而 [`casefold()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.casefold) 则会将其转换为 `"ss"`。消除大小写算法的描述请参见 Unicode 标准的 3.13 节。*3.3 新版功能.*

- `str.``center`(*width*[, *fillchar*])

  返回长度为 *width* 的字符串，原字符串在其正中。 使用指定的 *fillchar* 填充两边的空位（默认使用 ASCII 空格符）。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。

- `str.``count`(*sub*[, *start*[, *end*]])

  返回子字符串 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* 会被解读为切片表示法。

- `str.``encode`(*encoding="utf-8"*, *errors="strict"*)

  返回原字符串编码为字节串对象的版本。 默认编码为 `'utf-8'`。 可以给出 *errors* 来设置不同的错误处理方案。 *errors* 的默认值为 `'strict'`，表示编码错误会引发 [`UnicodeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#UnicodeError)。 其他可用的值为 `'ignore'`, `'replace'`, `'xmlcharrefreplace'`, `'backslashreplace'` 以及任何其他通过 [`codecs.register_error()`](https://docs.python.org/zh-cn/3/library/codecs.html#codecs.register_error) 注册的值，请参阅 [错误处理方案](https://docs.python.org/zh-cn/3/library/codecs.html#error-handlers) 小节。 要查看可用的编码列表，请参阅 [标准编码](https://docs.python.org/zh-cn/3/library/codecs.html#standard-encodings) 小节。*errors* 参数默认不会被检查，以获得最佳性能，而只在第一次编码错误时使用。启用 [Python 开发模式](https://docs.python.org/zh-cn/3/library/devmode.html#devmode) ，或者使用调试构建来检查 *errors* 。*在 3.1 版更改:* 加入了对关键字参数的支持。*在 3.9 版更改:* *errors* 现在在开发模式和调试模式下都会被检查。

- `str.``endswith`(*suffix*[, *start*[, *end*]])

  如果字符串以指定的 *suffix* 结束返回 `True`，否则返回 `False`。 *suffix* 也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。

- `str.``expandtabs`(*tabsize=8*)

  返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (`\t`)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (`\n`) 或回车符 (`\r`)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。>>>`>>> '01\t012\t0123\t01234'.expandtabs() '01      012     0123    01234' >>> '01\t012\t0123\t01234'.expandtabs(4) '01  012 0123    01234' `

- `str.``find`(*sub*[, *start*[, *end*]])

  返回子字符串 *sub* 在 `s[start:end]` 切片内被找到的最小索引。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果 *sub* 未被找到则返回 `-1`。注解 [`find()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.find) 方法应该只在你需要知道 *sub* 所在位置时使用。 要检查 *sub* 是否为子字符串，请使用 [`in`](https://docs.python.org/zh-cn/3/reference/expressions.html#in) 操作符:>>>`>>> 'Py' in 'Python' True `

- `str.``format`(**args*, ***kwargs*)

  执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 `{}` 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。>>>`>>> "The sum of 1 + 2 is {0}".format(1+2) 'The sum of 1 + 2 is 3' `请参阅 [格式字符串语法](https://docs.python.org/zh-cn/3/library/string.html#formatstrings) 了解有关可以在格式字符串中指定的各种格式选项的说明。注解 当使用 `n` 类型 (例如: `'{:n}'.format(1234)`) 来格式化数字 ([`int`](https://docs.python.org/zh-cn/3/library/functions.html#int), [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float), [`complex`](https://docs.python.org/zh-cn/3/library/functions.html#complex), [`decimal.Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 及其子类) 的时候，该函数会临时性地将 `LC_CTYPE` 区域设置为 `LC_NUMERIC` 区域以解码 `localeconv()` 的 `decimal_point` 和 `thousands_sep` 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 `LC_NUMERIC` 区域会与 `LC_CTYPE` 区域不一致。 这个临时更改会影响其他线程。*在 3.7 版更改:* 当使用 `n` 类型格式化数字时，该函数在某些情况下会临时性地将 `LC_CTYPE` 区域设置为 `LC_NUMERIC` 区域。

- `str.``format_map`(*mapping*)

  类似于 `str.format(**mapping)`，不同之处在于 `mapping` 会被直接使用而不是复制到一个 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict)。 适宜使用此方法的一个例子是当 `mapping` 为 dict 的子类的情况：>>>`>>> class Default(dict): ...     def __missing__(self, key): ...         return key ... >>> '{name} was born in {country}'.format_map(Default(name='Guido')) 'Guido was born in country' `*3.2 新版功能.*

- `str.``index`(*sub*[, *start*[, *end*]])

  类似于 [`find()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.find)，但在找不到子类时会引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。

- `str.``isalnum`()

  如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 `True` ， 否则返回 `False` 。 如果 `c.isalpha()` ， `c.isdecimal()` ， `c.isdigit()` ，或 `c.isnumeric()` 之中有一个返回 `True` ，则字符``c``是字母或数字。

- `str.``isalpha`()

  如果字符串中的所有字符都是字母，并且至少有一个字符，返回 `True` ，否则返回 `False` 。字母字符是指那些在 Unicode 字符数据库中定义为 "Letter" 的字符，即那些具有 "Lm"、"Lt"、"Lu"、"Ll" 或 "Lo" 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的"字母"属性不同。

- `str.``isascii`()

  如果字符串为空或字符串中的所有字符都是 ASCII ，返回 `True` ，否则返回 `False` 。ASCII 字符的码点范围是 U+0000-U+007F 。*3.7 新版功能.*

- `str.``isdecimal`()

  如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 `True` ， 否则返回 `False` 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 "Nd" 中的一个字符。

- `str.``isdigit`()

  如果字符串中的所有字符都是数字，并且至少有一个字符，返回 `True` ，否则返回 `False` 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。

- `str.``isidentifier`()

  如果字符串是有效的标识符，返回 `True` ，依据语言定义， [标识符和关键字](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#identifiers) 节。调用 [`keyword.iskeyword()`](https://docs.python.org/zh-cn/3/library/keyword.html#keyword.iskeyword) 来检测字符串 `s` 是否为保留标识符，例如 [`def`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def) 和 [`class`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class)。示例：>>>`>>> from keyword import iskeyword >>> 'hello'.isidentifier(), iskeyword('hello') True, False >>> 'def'.isidentifier(), iskeyword('def') True, True `

- `str.``islower`()

  如果字符串中至少有一个区分大小写的字符 [4](https://docs.python.org/zh-cn/3/library/stdtypes.html#id15) 且此类字符均为小写则返回 `True` ，否则返回 `False` 。

- `str.``isnumeric`()

  如果字符串中至少有一个字符且所有字符均为数值字符则返回 `True` ，否则返回 `False` 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。

- `str.``isprintable`()

  如果字符串中所有字符均为可打印字符或字符串为空则返回 `True` ，否则返回 `False` 。 不可打印字符是在 Unicode 字符数据库中被定义为 "Other" 或 "Separator" 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 [`repr()`](https://docs.python.org/zh-cn/3/library/functions.html#repr) 时不必被转义的字符。 它们与字符串写入 [`sys.stdout`](https://docs.python.org/zh-cn/3/library/sys.html#sys.stdout) 或 [`sys.stderr`](https://docs.python.org/zh-cn/3/library/sys.html#sys.stderr) 时所需的处理无关。）

- `str.``isspace`()

  如果字符串中只有空白字符且至少有一个字符则返回 `True` ，否则返回 `False` 。*空白* 字符是指在 Unicode 字符数据库 (参见 [`unicodedata`](https://docs.python.org/zh-cn/3/library/unicodedata.html#module-unicodedata)) 中主要类别为 `Zs` ("Separator, space") 或所属双向类为 `WS`, `B` 或 `S` 的字符。

- `str.``istitle`()

  如果字符串中至少有一个字符且为标题字符串则返回 `True` ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 `False` 。

- `str.``isupper`()

  如果字符串中至少有一个区分大小写的字符 [4](https://docs.python.org/zh-cn/3/library/stdtypes.html#id15) 且此类字符均为大写则返回 `True` ，否则返回 `False` 。>>>`>>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False `

- `str.``join`(*iterable*)

  返回一个由 *iterable* 中的字符串拼接而成的字符串。 如果 *iterable* 中存在任何非字符串值包括 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象则会引发 [`TypeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError)。 调用该方法的字符串将作为元素之间的分隔。

- `str.``ljust`(*width*[, *fillchar*])

  返回长度为 *width* 的字符串，原字符串在其中靠左对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。

- `str.``lower`()

  返回原字符串的副本，其所有区分大小写的字符 [4](https://docs.python.org/zh-cn/3/library/stdtypes.html#id15) 均转换为小写。所用转换小写算法的描述请参见 Unicode 标准的 3.13 节。

- `str.``lstrip`([*chars*])

  返回原字符串的副本，移除其中的前导字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空格符。 实际上 *chars* 参数并非指定单个前缀；而是会移除参数值的所有组合:>>>`>>> '   spacious   '.lstrip() 'spacious   ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' `参见 [`str.removeprefix()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.removeprefix) ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:>>>`>>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' `

- *static* `str.``maketrans`(*x*[, *y*[, *z*]])

  此静态方法返回一个可供 [`str.translate()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.translate) 使用的转换对照表。如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 `None` 的字典。 字符键将会被转换为码位序号。如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 `None`。

- `str.``partition`(*sep*)

  在 *sep* 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。

- `str.``removeprefix`(*prefix*, */*)

  如果字符串以 *前缀* 字符串开头，返回 `string[len(prefix):]` 。否则，返回原始字符串的副本：>>>`>>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' `*3.9 新版功能.*

- `str.``removesuffix`(*suffix*, */*)

  如果字符串以 *后缀* 字符串结尾，并且 *后缀* 非空，返回 `string[:-len(suffix)]` 。否则，返回原始字符串的副本：>>>`>>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' `*3.9 新版功能.*

- `str.``replace`(*old*, *new*[, *count*])

  返回字符串的副本，其中出现的所有子字符串 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。

- `str.``rfind`(*sub*[, *start*[, *end*]])

  返回子字符串 *sub* 在字符串内被找到的最大（最右）索引，这样 *sub* 将包含在 `s[start:end]` 当中。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果未找到则返回 `-1`。

- `str.``rindex`(*sub*[, *start*[, *end*]])

  类似于 [`rfind()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.rfind)，但在子字符串 *sub* 未找到时会引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。

- `str.``rjust`(*width*[, *fillchar*])

  返回长度为 *width* 的字符串，原字符串在其中靠右对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。

- `str.``rpartition`(*sep*)

  在 *sep* 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。

- `str.``rsplit`(*sep=None*, *maxsplit=-1*)

  返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 *最右边* 开始。 如果 *sep* 未指定或为 `None`，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，[`rsplit()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.rsplit) 的其他行为都类似于下文所述的 [`split()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.split)。

- `str.``rstrip`([*chars*])

  返回原字符串的副本，移除其中的末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空格符。 实际上 *chars* 参数并非指定单个后缀；而是会移除参数值的所有组合:>>>`>>> '   spacious   '.rstrip() '   spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' `要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 [`str.removesuffix()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.removesuffix) 方法。 例如:>>>`>>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' `

- `str.``split`(*sep=None*, *maxsplit=-1*)

  返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分（因此，列表最多会有 `maxsplit+1` 个元素）。 如果 *maxsplit* 未指定或为 `-1`，则不限制拆分次数（进行所有可能的拆分）。如果给出了 *sep*，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 `'1,,2'.split(',')` 将返回 `['1', '', '2']`)。 *sep* 参数可能由多个字符组成 (例如 `'1<>2<>3'.split('<>')` 将返回 `['1', '2', '3']`)。 使用指定的分隔符拆分空字符串将返回 `['']`。例如:>>>`>>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] `如果 *sep* 未指定或为 `None`，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 `None` 拆分空字符串或仅包含空格的字符串将返回 `[]`。例如:>>>`>>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> '   1   2   3   '.split() ['1', '2', '3'] `



- `str.``splitlines`([*keepends*])

  返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 *keepends* 且为真值。此方法会以下列行边界进行拆分。 特别地，行边界是 [universal newlines](https://docs.python.org/zh-cn/3/glossary.html#term-universal-newlines) 的一个超集。表示符描述`\n`换行`\r`回车`\r\n`回车 + 换行`\v` 或 `\x0b`行制表符`\f` 或 `\x0c`换表单`\x1c`文件分隔符`\x1d`组分隔符`\x1e`记录分隔符`\x85`下一行 (C1 控制码)`\u2028`行分隔符`\u2029`段分隔符*在 3.2 版更改:* `\v` 和 `\f` 被添加到行边界列表例如:>>>`>>> 'ab c\n\nde fg\rkl\r\n'.splitlines() ['ab c', '', 'de fg', 'kl'] >>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True) ['ab c\n', '\n', 'de fg\r', 'kl\r\n'] `不同于 [`split()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.split)，当给出了分隔字符串 *sep* 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:>>>`>>> "".splitlines() [] >>> "One line\n".splitlines() ['One line'] `作为比较，`split('\n')` 的结果为:>>>`>>> ''.split('\n') [''] >>> 'Two lines\n'.split('\n') ['Two lines', ''] `

- `str.``startswith`(*prefix*[, *start*[, *end*]])

  如果字符串以指定的 *prefix* 开始则返回 `True`，否则返回 `False`。 *prefix* 也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。

- `str.``strip`([*chars*])

  返回原字符串的副本，移除其中的前导和末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空格符。 实际上 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:>>>`>>> '   spacious   '.strip() 'spacious' >>> 'www.example.com'.strip('cmowz.') 'example' `最外侧的前导和末尾 *chars* 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 *chars* 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:>>>`>>> comment_string = '#....... Section 3.2.1 Issue #32 .......' >>> comment_string.strip('.#! ') 'Section 3.2.1 Issue #32' `

- `str.``swapcase`()

  返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 `s.swapcase().swapcase() == s` 并不一定为真值。

- `str.``title`()

  返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。例如:>>>`>>> 'Hello world'.title() 'Hello World' `该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:>>>`>>> "they're bill's friends from the UK".title() "They'Re Bill'S Friends From The Uk" `可以使用正则表达式来构建针对撇号的特别处理:>>>`>>> import re >>> def titlecase(s): ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?", ...                   lambda mo: mo.group(0).capitalize(), ...                   s) ... >>> titlecase("they're bill's friends.") "They're Bill's Friends." `

- `str.``translate`(*table*)

  返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 [`__getitem__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__) 来实现索引操作的对象，通常为 [mapping](https://docs.python.org/zh-cn/3/glossary.html#term-mapping) 或 [sequence](https://docs.python.org/zh-cn/3/glossary.html#term-sequence)。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 `None`，将字符从结果字符串中删除；或引发 [`LookupError`](https://docs.python.org/zh-cn/3/library/exceptions.html#LookupError) 异常，将字符映射为其自身。你可以使用 [`str.maketrans()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.maketrans) 基于不同格式的字符到字符映射来创建一个转换映射表。另请参阅 [`codecs`](https://docs.python.org/zh-cn/3/library/codecs.html#module-codecs) 模块以了解定制字符映射的更灵活方式。

- `str.``upper`()

  返回原字符串的副本，其中所有区分大小写的字符 [4](https://docs.python.org/zh-cn/3/library/stdtypes.html#id15) 均转换为大写。 请注意如果 `s` 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 "Lu" (Letter, uppercase) 而是 "Lt" (Letter, titlecase) 则 `s.upper().isupper()` 有可能为 `False`。所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。

- `str.``zfill`(*width*)

  返回原字符串的副本，在左边填充 ASCII `'0'` 数码使其长度变为 *width*。 正负值前缀 (`'+'`/`'-'`) 的处理方式是在正负符号 *之后* 填充而非在之前。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。例如:>>>`>>> "42".zfill(5) '00042' >>> "-42".zfill(5) '-0042' `



### `printf` 风格的字符串格式化

注解

 

此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 [格式化字符串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings)，[`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 接口或 [模板字符串](https://docs.python.org/zh-cn/3/library/string.html#template-strings) 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。

字符串具有一种特殊的内置操作：使用 `%` (取模) 运算符。 这也被称为字符串的 *格式化* 或 *插值* 运算符。 对于 `format % values` (其中 *format* 为一个字符串)，在 *format* 中的 `%` 转换标记符将被替换为零个或多个 *values* 条目。 其效果类似于在 C 语言中使用 `sprintf()`。

如果 *format* 要求一个单独参数，则 *values* 可以为一个非元组对象。 [5](https://docs.python.org/zh-cn/3/library/stdtypes.html#id16) 否则的话，*values* 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。

转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：

1. `'%'` 字符，用于标记转换符的起始。
2. 映射键（可选），由加圆括号的字符序列组成 (例如 `(somename)`)。
3. 转换旗标（可选），用于影响某些转换类型的结果。
4. 最小字段宽度（可选）。 如果指定为 `'*'` (星号)，则实际宽度会从 *values* 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。
5. 精度（可选），以在 `'.'` (点号) 之后加精度值的形式给出。 如果指定为 `'*'` (星号)，则实际精度会从 *values* 元组的下一元素中读取，要转换的对象则为精度之后的元素。
6. 长度修饰符（可选）。
7. 转换类型。

当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 *必须* 包含加圆括号的映射键，对应 `'%'` 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：

\>>>

```
>>> print('%(language)s has %(number)03d quote types.' %
...       {'language': "Python", "number": 2})
Python has 002 quote types.
```

在此情况下格式中不能出现 `*` 标记符（因其需要一个序列类的参数列表）。

转换旗标为：

| 标志  | 含义                                                         |
| :---- | :----------------------------------------------------------- |
| `'#'` | 值的转换将使用“替代形式”（具体定义见下文）。                 |
| `'0'` | 转换将为数字值填充零字符。                                   |
| `'-'` | 转换值将靠左对齐（如果同时给出 `'0'` 转换，则会覆盖后者）。  |
| `' '` | (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。  |
| `'+'` | 符号字符 (`'+'` 或 `'-'`) 将显示于转换结果的开头（会覆盖 "空格" 旗标）。 |

可以给出长度修饰符 (`h`, `l` 或 `L`)，但会被忽略，因为对 Python 来说没有必要 -- 所以 `%ld` 等价于 `%d`。

转换类型为：

| 转换符 | 含义                                                         | 注释 |
| :----- | :----------------------------------------------------------- | :--- |
| `'d'`  | 有符号十进制整数。                                           |      |
| `'i'`  | 有符号十进制整数。                                           |      |
| `'o'`  | 有符号八进制数。                                             | (1)  |
| `'u'`  | 过时类型 -- 等价于 `'d'`。                                   | (6)  |
| `'x'`  | 有符号十六进制数（小写）。                                   | (2)  |
| `'X'`  | 有符号十六进制数（大写）。                                   | (2)  |
| `'e'`  | 浮点指数格式（小写）。                                       | (3)  |
| `'E'`  | 浮点指数格式（大写）。                                       | (3)  |
| `'f'`  | 浮点十进制格式。                                             | (3)  |
| `'F'`  | 浮点十进制格式。                                             | (3)  |
| `'g'`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。 | (4)  |
| `'G'`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。 | (4)  |
| `'c'`  | 单个字符（接受整数或单个字符的字符串）。                     |      |
| `'r'`  | 字符串（使用 [`repr()`](https://docs.python.org/zh-cn/3/library/functions.html#repr) 转换任何 Python 对象）。 | (5)  |
| `'s'`  | 字符串（使用 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 转换任何 Python 对象）。 | (5)  |
| `'a'`  | 字符串（使用 [`ascii()`](https://docs.python.org/zh-cn/3/library/functions.html#ascii) 转换任何 Python 对象）。 | (5)  |
| `'%'`  | 不转换参数，在结果中输出一个 `'%'` 字符。                    |      |

注释:

1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 (`'0o'`)。

2. 此替代形式会在第一个数码之前插入 `'0x'` 或 `'0X'` 前缀（取决于是使用 `'x'` 还是 `'X'` 格式）。

3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。

   小数点后的数码位数由精度决定，默认为 6。

4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。

   小数点前后的有效数码位数由精度决定，默认为 6。

5. 如果精度为 `N`，输出将截短为 `N` 个字符。

6. 参见 [**PEP 237**](https://www.python.org/dev/peps/pep-0237)。

由于 Python 字符串显式指明长度，`%s` 转换不会将 `'\0'` 视为字符串的结束。

*在 3.1 版更改:* 绝对值超过 1e50 的 `%f` 转换不会再被替换为 `%g` 转换。



## 二进制序列类型 --- [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes), [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray), [`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview)

操作二进制数据的核心内置类型是 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 和 [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray)。 它们由 [`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview) 提供支持，该对象使用 [缓冲区协议](https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects) 来访问其他二进制对象所在内存，不需要创建对象的副本。

[`array`](https://docs.python.org/zh-cn/3/library/array.html#module-array) 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。



### bytes 对象

bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。

- *class* `bytes`([*source*[, *encoding*[, *errors*]]])

  首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 `b` 前缀：单引号: `b'同样允许嵌入 "双" 引号'`。双引号: `b"同样允许嵌入 '单' 引号"`。三重引号: `b'''三重单引号'''`, `b"""三重双引号"""`bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。像字符串字面值一样，bytes 字面值也可以使用 `r` 前缀来禁用转义序列处理。 请参阅 [字符串与字节串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#strings) 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 `0 <= x < 256` (如果违反此限制将引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError))。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。除了字面值形式，bytes 对象还可以通过其他几种方式来创建：指定长度的以零值填充的 bytes 对象: `bytes(10)`通过由整数组成的可迭代对象: `bytes(range(20))`通过缓冲区协议复制现有的二进制数据: `bytes(obj)`另请参阅 [bytes](https://docs.python.org/zh-cn/3/library/functions.html#func-bytes) 内置类型。由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：*classmethod* `fromhex`(*string*)此 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。>>>`>>> bytes.fromhex('2Ef0 F1f2  ') b'.\xf0\xf1\xf2' `*在 3.7 版更改:* [`bytes.fromhex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.fromhex) 现在会忽略所有 ASCII 空白符而不只是空格符。存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。`hex`([*sep*[, *bytes_per_sep*]])返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。>>>`>>> b'\xf0\xf1\xf2'.hex() 'f0f1f2' `如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 *sep* 形参包含于输出中。 默认会放在每个字节之间。 第二个可选的 *bytes_per_sep* 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。>>>`>>> value = b'\xf0\xf1\xf2' >>> value.hex('-') 'f0-f1-f2' >>> value.hex('_', 2) 'f0_f1f2' >>> b'UUDDLRLRAB'.hex(' ', -4) '55554444 4c524c52 4142' `*3.5 新版功能.**在 3.8 版更改:* [`bytes.hex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.hex) 现在支持可选的 *sep* 和 *bytes_per_sep* 形参以在十六进制输出的字节之间插入分隔符。

由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 *b*，`b[0]` 将为一个整数，而 `b[0:1]` 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。

bytes 对象的表示使用字面值格式 (`b'...'`)，因为它通常都要比像 `bytes([46, 46, 46])` 这样的格式更好用。 你总是可以使用 `list(b)` 将 bytes 对象转换为一个由整数构成的列表。

注解

 

针对 Python 2.x 用户的说明：在 Python 2.x 系列中，允许 8 位字符串（ 2.x 所提供的最接近内置二进制数据类型的对象）与 Unicode 字符串进行各种隐式转换。 这是为了实现向下兼容的变通做法，以适应 Python 最初只支持 8 位文本而 Unicode 文本是后来才被加入这一事实。 在 Python 3.x 中，这些隐式转换已被取消 —— 8 位二进制数据与 Unicode 文本间的转换必须显式地进行，bytes 与字符串对象的比较结果将总是不相等。



### bytearray 对象

[`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray) 对象是 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象的可变对应物。

- *class* `bytearray`([*source*[, *encoding*[, *errors*]]])

  bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：创建一个空实例: `bytearray()`创建一个指定长度的以零值填充的实例: `bytearray(10)`通过由整数组成的可迭代对象: `bytearray(range(20))`通过缓冲区协议复制现有的二进制数据: `bytearray(b'Hi!')`由于 bytearray 对象是可变的，该对象除了 [bytes 和 bytearray 操作](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes-methods) 中所描述的 bytes 和 bytearray 共有操作之外，还支持 [可变](https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq-mutable) 序列操作。另请参见 [bytearray](https://docs.python.org/zh-cn/3/library/functions.html#func-bytearray) 内置类型。由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：*classmethod* `fromhex`(*string*)[`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray) 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。>>>`>>> bytearray.fromhex('2Ef0 F1f2  ') bytearray(b'.\xf0\xf1\xf2') `*在 3.7 版更改:* [`bytearray.fromhex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray.fromhex) 现在会忽略所有 ASCII 空白符而不只是空格符。存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。`hex`([*sep*[, *bytes_per_sep*]])返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。>>>`>>> bytearray(b'\xf0\xf1\xf2').hex() 'f0f1f2' `*3.5 新版功能.**在 3.8 版更改:* 与 [`bytes.hex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.hex) 相似， [`bytearray.hex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray.hex) 现在支持可选的 *sep* 和 *bytes_per_sep* 参数以在十六进制输出的字节之间插入分隔符。

由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 *b*，`b[0]` 将为一个整数，而 `b[0:1]` 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。

bytearray 对象的表示使用 bytes 对象字面值格式 (`bytearray(b'...')`)，因为它通常都要比 `bytearray([46, 46, 46])` 这样的格式更好用。 你总是可以使用 `list(b)` 将 bytearray 对象转换为一个由整数构成的列表。



### bytes 和 bytearray 操作

bytes 和 bytearray 对象都支持 [通用](https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq-common) 序列操作。 它们不仅能与相同类型的操作数，也能与任何 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。

注解

 

bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 例如，你必须使用以下写法:

```
a = "abc"
b = a.replace("a", "f")
```

和:

```
a = b"abc"
b = a.replace(b"a", b"f")
```

某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。

注解

 

使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。

bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。

- `bytes.``count`(*sub*[, *start*[, *end*]])

- `bytearray.``count`(*sub*[, *start*[, *end*]])

  返回子序列 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* 会被解读为切片表示法。要搜索的子序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 或是 0 至 255 范围内的整数。*在 3.3 版更改:* 也接受 0 至 255 范围内的整数作为子序列。

- `bytes.``removeprefix`(*prefix*, */*)

- `bytearray.``removeprefix`(*prefix*, */*)

  如果二进制数据以 *前缀* 字符串开头，返回 `bytes[len(prefix):]` 。否则，返回原始二进制数据的副本：>>>`>>> b'TestHook'.removeprefix(b'Test') b'Hook' >>> b'BaseTestCase'.removeprefix(b'Test') b'BaseTestCase' `前缀可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。*3.9 新版功能.*

- `bytes.``removesuffix`(*suffix*, */*)

- `bytearray.``removesuffix`(*suffix*, */*)

  如果二进制数据以 *后缀* 字符串结尾，并且 *后缀* 非空，返回 `bytes[:-len(suffix)]` 。否则，返回原始二进制数据的副本：>>>`>>> b'MiscTests'.removesuffix(b'Tests') b'Misc' >>> b'TmpDirMixin'.removesuffix(b'Tests') b'TmpDirMixin' `后缀可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。*3.9 新版功能.*

- `bytes.``decode`(*encoding="utf-8"*, *errors="strict"*)

- `bytearray.``decode`(*encoding="utf-8"*, *errors="strict"*)

  返回从给定 bytes 解码出来的字符串。 默认编码为 `'utf-8'`。 可以给出 *errors* 来设置不同的错误处理方案。 *errors* 的默认值为 `'strict'`，表示编码错误会引发 [`UnicodeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#UnicodeError)。 其他可用的值为 `'ignore'`, `'replace'` 以及任何其他通过 [`codecs.register_error()`](https://docs.python.org/zh-cn/3/library/codecs.html#codecs.register_error) 注册的名称，请参阅 [错误处理方案](https://docs.python.org/zh-cn/3/library/codecs.html#error-handlers) 小节。 要查看可用的编码列表，请参阅 [标准编码](https://docs.python.org/zh-cn/3/library/codecs.html#standard-encodings) 小节。*errors* 参数默认不会被检查，以获得最佳性能，而只在第一次解码错误时使用。启用 [Python 开发模式](https://docs.python.org/zh-cn/3/library/devmode.html#devmode) ，或者使用调试构建来检查 *errors* 。注解 将 *encoding* 参数传给 [`str`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 允许直接解码任何 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)，无须创建临时的 bytes 或 bytearray 对象。*在 3.1 版更改:* 加入了对关键字参数的支持。*在 3.9 版更改:* *errors* 现在在开发模式和调试模式下都会被检查。

- `bytes.``endswith`(*suffix*[, *start*[, *end*]])

- `bytearray.``endswith`(*suffix*[, *start*[, *end*]])

  如果二进制数据以指定的 *suffix* 结束则返回 `True`，否则返回 `False`。 *suffix* 也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。要搜索的后缀可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。

- `bytes.``find`(*sub*[, *start*[, *end*]])

- `bytearray.``find`(*sub*[, *start*[, *end*]])

  返回子序列 *sub* 在数据中被找到的最小索引，*sub* 包含于切片 `s[start:end]` 之内。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果 *sub* 未被找到则返回 `-1`。要搜索的子序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 或是 0 至 255 范围内的整数。注解 [`find()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.find) 方法应该只在你需要知道 *sub* 所在位置时使用。 要检查 *sub* 是否为子串，请使用 [`in`](https://docs.python.org/zh-cn/3/reference/expressions.html#in) 操作符:>>>`>>> b'Py' in b'Python' True `*在 3.3 版更改:* 也接受 0 至 255 范围内的整数作为子序列。

- `bytes.``index`(*sub*[, *start*[, *end*]])

- `bytearray.``index`(*sub*[, *start*[, *end*]])

  类似于 [`find()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.find)，但在找不到子序列时会引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。要搜索的子序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 或是 0 至 255 范围内的整数。*在 3.3 版更改:* 也接受 0 至 255 范围内的整数作为子序列。

- `bytes.``join`(*iterable*)

- `bytearray.``join`(*iterable*)

  返回一个由 *iterable* 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 *iterable* 中存在任何非 [字节类对象](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 包括存在 [`str`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 对象值则会引发 [`TypeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError)。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。

- *static* `bytes.``maketrans`(*from*, *to*)

- *static* `bytearray.``maketrans`(*from*, *to*)

  此静态方法返回一个可用于 [`bytes.translate()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.translate) 的转换对照表，它将把 *from* 中的每个字符映射为 *to* 中相同位置上的字符；*from* 与 *to* 必须都是 [字节类对象](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 并且具有相同的长度。*3.1 新版功能.*

- `bytes.``partition`(*sep*)

- `bytearray.``partition`(*sep*)

  在 *sep* 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。要搜索的分隔符可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。

- `bytes.``replace`(*old*, *new*[, *count*])

- `bytearray.``replace`(*old*, *new*[, *count*])

  返回序列的副本，其中出现的所有子序列 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。要搜索的子序列及其替换序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``rfind`(*sub*[, *start*[, *end*]])

- `bytearray.``rfind`(*sub*[, *start*[, *end*]])

  返回子序列 *sub* 在序列内被找到的最大（最右）索引，这样 *sub* 将包含在 `s[start:end]` 当中。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果未找到则返回 `-1`。要搜索的子序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 或是 0 至 255 范围内的整数。*在 3.3 版更改:* 也接受 0 至 255 范围内的整数作为子序列。

- `bytes.``rindex`(*sub*[, *start*[, *end*]])

- `bytearray.``rindex`(*sub*[, *start*[, *end*]])

  类似于 [`rfind()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.rfind)，但在子序列 *sub* 未找到时会引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。要搜索的子序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 或是 0 至 255 范围内的整数。*在 3.3 版更改:* 也接受 0 至 255 范围内的整数作为子序列。

- `bytes.``rpartition`(*sep*)

- `bytearray.``rpartition`(*sep*)

  在 *sep* 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。要搜索的分隔符可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。

- `bytes.``startswith`(*prefix*[, *start*[, *end*]])

- `bytearray.``startswith`(*prefix*[, *start*[, *end*]])

  如果二进制数据以指定的 *prefix* 开头则返回 `True`，否则返回 `False`。 *prefix* 也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。要搜索的前缀可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。

- `bytes.``translate`(*table*, */*, *delete=b''*)

- `bytearray.``translate`(*table*, */*, *delete=b''*)

  返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 *delete* 中出现的 bytes，其余 bytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。你可以使用 [`bytes.maketrans()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.maketrans) 方法来创建转换表。对于仅需移除字符的转换，请将 *table* 参数设为 `None`:>>>`>>> b'read this short text'.translate(None, b'aeiou') b'rd ths shrt txt' `*在 3.6 版更改:* 现在支持将 *delete* 作为关键字参数。

以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 *不是* 原地执行操作，而是会产生新的对象。

- `bytes.``center`(*width*[, *fillbyte*])

- `bytearray.``center`(*width*[, *fillbyte*])

  返回原对象的副本，在长度为 *width* 的序列内居中，使用指定的 *fillbyte* 填充两边的空位（默认使用 ASCII 空格符）。 对于 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象，如果 *width* 小于等于 `len(s)` 则返回原序列的副本。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``ljust`(*width*[, *fillbyte*])

- `bytearray.``ljust`(*width*[, *fillbyte*])

  返回原对象的副本，在长度为 *width* 的序列中靠左对齐。 使用指定的 *fillbyte* 填充空位（默认使用 ASCII 空格符）。 对于 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象，如果 *width* 小于等于 `len(s)` 则返回原序列的副本。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``lstrip`([*chars*])

- `bytearray.``lstrip`([*chars*])

  返回原序列的副本，移除指定的前导字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 `None`，则 *chars* 参数默认移除 ASCII 空白符。 *chars* 参数并非指定单个前缀；而是会移除参数值的所有组合:>>>`>>> b'   spacious   '.lstrip() b'spacious   ' >>> b'www.example.com'.lstrip(b'cmowz.') b'example.com' `要移除的二进制序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 。 要删除单个前缀字符串，而不是全部给定集合中的字符，请参见 [`str.removeprefix()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.removeprefix) 方法。 例如:>>>`>>> b'Arthur: three!'.lstrip(b'Arthur: ') b'ee!' >>> b'Arthur: three!'.removeprefix(b'Arthur: ') b'three!' `注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``rjust`(*width*[, *fillbyte*])

- `bytearray.``rjust`(*width*[, *fillbyte*])

  返回原对象的副本，在长度为 *width* 的序列中靠右对齐。 使用指定的 *fillbyte* 填充空位（默认使用 ASCII 空格符）。 对于 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象，如果 *width* 小于等于 `len(s)` 则返回原序列的副本。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``rsplit`(*sep=None*, *maxsplit=-1*)

- `bytearray.``rsplit`(*sep=None*, *maxsplit=-1*)

  将二进制序列拆分为相同类型的子序列，使用 *sep* 作为分隔符。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 *最右边* 开始。 如果 *sep* 未指定或为 `None`，任何只包含 ASCII 空白符的子序列都会被作为分隔符。 除了从右边开始拆分，[`rsplit()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray.rsplit) 的其他行为都类似于下文所述的 [`split()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray.split)。

- `bytes.``rstrip`([*chars*])

- `bytearray.``rstrip`([*chars*])

  返回原序列的副本，移除指定的末尾字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 `None`，则 *chars* 参数默认移除 ASCII 空白符。 *chars* 参数并非指定单个后缀；而是会移除参数值的所有组合:>>>`>>> b'   spacious   '.rstrip() b'   spacious' >>> b'mississippi'.rstrip(b'ipz') b'mississ' `要移除的二进制序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object) 。 要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 [`str.removesuffix()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.removesuffix) 方法。 例如:>>>`>>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' `注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``split`(*sep=None*, *maxsplit=-1*)

- `bytearray.``split`(*sep=None*, *maxsplit=-1*)

  将二进制序列拆分为相同类型的子序列，使用 *sep* 作为分隔符。 如果给出了 *maxsplit* 且非负值，则最多进行 *maxsplit* 次拆分（因此，列表最多会有 `maxsplit+1` 个元素）。 如果 *maxsplit* 未指定或为 `-1`，则不限制拆分次数（进行所有可能的拆分）。如果给出了 *sep*，则连续的分隔符不会被组合在一起而是被视为分隔空子序列 (例如 `b'1,,2'.split(b',')` 将返回 `[b'1', b'', b'2']`)。 *sep* 参数可能为一个多字节序列 (例如 `b'1<>2<>3'.split(b'<>')` 将返回 `[b'1', b'2', b'3']`)。 使用指定的分隔符拆分空序列将返回 `[b'']` 或 `[bytearray(b'')]`，具体取决于被拆分对象的类型。 *sep* 参数可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。例如:>>>`>>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] `如果 *sep* 未指定或为 `None`，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅包含 ASCII 空白符的序列进行拆分将返回 `[]`。例如:>>>`>>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b'   1   2   3   '.split() [b'1', b'2', b'3'] `

- `bytes.``strip`([*chars*])

- `bytearray.``strip`([*chars*])

  返回原序列的副本，移除指定的开头和末尾字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 `None`，则 *chars* 参数默认移除 ASCII 空白符。 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:>>>`>>> b'   spacious   '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' `要移除的字节值二进制序列可以是任意 [bytes-like object](https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object)。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 *不是* 原地执行操作，而是会产生新的对象。

- `bytes.``capitalize`()

- `bytearray.``capitalize`()

  返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大写而其余的小写。 非 ASCII 字节值将保持原样不变。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``expandtabs`(*tabsize=8*)

- `bytearray.``expandtabs`(*tabsize=8*)

  返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* 个字节设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。 如果字节为 ASCII 制表符 (`b'\t'`)，则并在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (`b'\n'`) 或回车符 (`b'\r'`)，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加一，不论该字节值在被打印时会如何显示:>>>`>>> b'01\t012\t0123\t01234'.expandtabs() b'01      012     0123    01234' >>> b'01\t012\t0123\t01234'.expandtabs(4) b'01  012 0123    01234' `注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``isalnum`()

- `bytearray.``isalnum`()

  如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 `True` ，否则返回 `False` 。 字母类 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。 ASCII 十进制数码就是字节值包含在序列 `b'0123456789'` 中的字符。例如:>>>`>>> b'ABCabc1'.isalnum() True >>> b'ABC abc1'.isalnum() False `

- `bytes.``isalpha`()

- `bytearray.``isalpha`()

  如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 `True` ，否则返回 `False` 。 字母类 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。例如:>>>`>>> b'ABCabc'.isalpha() True >>> b'ABCabc1'.isalpha() False `

- `bytes.``isascii`()

- `bytearray.``isascii`()

  如果序列为空或序列中所有字节都是 ASCII 字节则返回 `True` ，否则返回 `False` 。 ASCII 字节的取值范围是 0-0x7F。*3.7 新版功能.*

- `bytes.``isdigit`()

- `bytearray.``isdigit`()

  如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 `True` ，否则返回 `False` 。 ASCII 十进制数码就是字节值包含在序列 `b'0123456789'` 中的字符。例如:>>>`>>> b'1234'.isdigit() True >>> b'1.23'.isdigit() False `

- `bytes.``islower`()

- `bytearray.``islower`()

  如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 `True` ，否则返回 `False` 。例如:>>>`>>> b'hello world'.islower() True >>> b'Hello world'.islower() False `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。

- `bytes.``isspace`()

- `bytearray.``isspace`()

  如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 `True` ，否则返回 `False` 。 ASCII 空白符就是字节值包含在序列 `b' \t\n\r\x0b\f'` (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。

- `bytes.``istitle`()

- `bytearray.``istitle`()

  如果序列为 ASCII 标题大小写形式并且序列非空则返回 `True` ，否则返回 `False` 。 请参阅 [`bytes.title()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.title) 了解有关“标题大小写”的详细定义。例如:>>>`>>> b'Hello World'.istitle() True >>> b'Hello world'.istitle() False `

- `bytes.``isupper`()

- `bytearray.``isupper`()

  如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 `True` ，否则返回 `False` 。例如:>>>`>>> b'HELLO WORLD'.isupper() True >>> b'Hello world'.isupper() False `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。

- `bytes.``lower`()

- `bytearray.``lower`()

  返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。例如:>>>`>>> b'Hello World'.lower() b'hello world' `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。



- `bytes.``splitlines`(*keepends=False*)

- `bytearray.``splitlines`(*keepends=False*)

  返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 [universal newlines](https://docs.python.org/zh-cn/3/glossary.html#term-universal-newlines) 方式来分行。 结果列表中不包含换行符，除非给出了 *keepends* 且为真值。例如:>>>`>>> b'ab c\n\nde fg\rkl\r\n'.splitlines() [b'ab c', b'', b'de fg', b'kl'] >>> b'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True) [b'ab c\n', b'\n', b'de fg\r', b'kl\r\n'] `不同于 [`split()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.split)，当给出了分隔符 *sep* 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:>>>`>>> b"".split(b'\n'), b"Two lines\n".split(b'\n') ([b''], [b'Two lines', b'']) >>> b"".splitlines(), b"One line\n".splitlines() ([], [b'One line']) `

- `bytes.``swapcase`()

- `bytearray.``swapcase`()

  返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。例如:>>>`>>> b'Hello World'.swapcase() b'hELLO wORLD' `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。不同于 [`str.swapcase()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.swapcase)，在些二进制版本下 `bin.swapcase().swapcase() == bin` 总是成立。 大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``title`()

- `bytearray.``title`()

  返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小写。 不区别大小写的字节值将保持原样不变。例如:>>>`>>> b'Hello world'.title() b'Hello World' `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。 所有其他字节值都不区分大小写。该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:>>>`>>> b"they're bill's friends from the UK".title() b"They'Re Bill'S Friends From The Uk" `可以使用正则表达式来构建针对撇号的特别处理:>>>`>>> import re >>> def titlecase(s): ...     return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?", ...                   lambda mo: mo.group(0)[0:1].upper() + ...                              mo.group(0)[1:].lower(), ...                   s) ... >>> titlecase(b"they're bill's friends.") b"They're Bill's Friends." `注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``upper`()

- `bytearray.``upper`()

  返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。例如:>>>`>>> b'Hello World'.upper() b'HELLO WORLD' `小写 ASCII 字符就是字节值包含在序列 `b'abcdefghijklmnopqrstuvwxyz'` 中的字符。 大写 ASCII 字符就是字节值包含在序列 `b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` 中的字符。注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

- `bytes.``zfill`(*width*)

- `bytearray.``zfill`(*width*)

  返回原序列的副本，在左边填充 `b'0'` 数码使序列长度为 *width*。 正负值前缀 (`b'+'`/ `b'-'`) 的处理方式是在正负符号 *之后* 填充而非在之前。 对于 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 对象，如果 *width* 小于等于 `len(seq)` 则返回原序列。例如:>>>`>>> b"42".zfill(5) b'00042' >>> b"-42".zfill(5) b'-0042' `注解 此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。



### `printf` 风格的字节串格式化

注解

 

此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。

字节串对象 (`bytes`/`bytearray`) 具有一种特殊的内置操作：使用 `%` (取模) 运算符。 这也被称为字节串的 *格式化* 或 *插值* 运算符。 对于 `format % values` (其中 *format* 为一个字节串对象)，在 *format* 中的 `%` 转换标记符将被替换为零个或多个 *values* 条目。 其效果类似于在 C 语言中使用 `sprintf()`。

如果 *format* 要求一个单独参数，则 *values* 可以为一个非元组对象。 [5](https://docs.python.org/zh-cn/3/library/stdtypes.html#id16) 否则的话，*values* 必须或是是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象（例如元组）。

转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：

1. `'%'` 字符，用于标记转换符的起始。
2. 映射键（可选），由加圆括号的字符序列组成 (例如 `(somename)`)。
3. 转换旗标（可选），用于影响某些转换类型的结果。
4. 最小字段宽度（可选）。 如果指定为 `'*'` (星号)，则实际宽度会从 *values* 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。
5. 精度（可选），以在 `'.'` (点号) 之后加精度值的形式给出。 如果指定为 `'*'` (星号)，则实际精度会从 *values* 元组的下一元素中读取，要转换的对象则为精度之后的元素。
6. 长度修饰符（可选）。
7. 转换类型。

当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 *必须* 包含加圆括号的映射键，对应 `'%'` 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：

\>>>

```
>>> print(b'%(language)s has %(number)03d quote types.' %
...       {b'language': b"Python", b"number": 2})
b'Python has 002 quote types.'
```

在此情况下格式中不能出现 `*` 标记符（因其需要一个序列类的参数列表）。

转换旗标为：

| 标志  | 含义                                                         |
| :---- | :----------------------------------------------------------- |
| `'#'` | 值的转换将使用“替代形式”（具体定义见下文）。                 |
| `'0'` | 转换将为数字值填充零字符。                                   |
| `'-'` | 转换值将靠左对齐（如果同时给出 `'0'` 转换，则会覆盖后者）。  |
| `' '` | (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。  |
| `'+'` | 符号字符 (`'+'` 或 `'-'`) 将显示于转换结果的开头（会覆盖 "空格" 旗标）。 |

可以给出长度修饰符 (`h`, `l` 或 `L`)，但会被忽略，因为对 Python 来说没有必要 -- 所以 `%ld` 等价于 `%d`。

转换类型为：

| 转换符 | 含义                                                         | 注释 |
| :----- | :----------------------------------------------------------- | :--- |
| `'d'`  | 有符号十进制整数。                                           |      |
| `'i'`  | 有符号十进制整数。                                           |      |
| `'o'`  | 有符号八进制数。                                             | (1)  |
| `'u'`  | 过时类型 -- 等价于 `'d'`。                                   | (8)  |
| `'x'`  | 有符号十六进制数（小写）。                                   | (2)  |
| `'X'`  | 有符号十六进制数（大写）。                                   | (2)  |
| `'e'`  | 浮点指数格式（小写）。                                       | (3)  |
| `'E'`  | 浮点指数格式（大写）。                                       | (3)  |
| `'f'`  | 浮点十进制格式。                                             | (3)  |
| `'F'`  | 浮点十进制格式。                                             | (3)  |
| `'g'`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。 | (4)  |
| `'G'`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。 | (4)  |
| `'c'`  | 单个字节（接受整数或单个字节对象）。                         |      |
| `'b'`  | 字节串（任何遵循 [缓冲区协议](https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects) 或是具有 [`__bytes__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bytes__) 的对象）。 | (5)  |
| `'s'`  | `'s'` 是 `'b'` 的一个别名，只应当在基于 Python2/3 的代码中使用。 | (6)  |
| `'a'`  | 字节串（使用 `repr(obj).encode('ascii','backslashreplace)` 转换任何 Python 对象）。 | (5)  |
| `'r'`  | `'r'` 是 `'a'` 的一个别名，只应当在基于 Python2/3 的代码中使用。 | (7)  |
| `'%'`  | 不转换参数，在结果中输出一个 `'%'` 字符。                    |      |

注释:

1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 (`'0o'`)。

2. 此替代形式会在第一个数码之前插入 `'0x'` 或 `'0X'` 前缀（取决于是使用 `'x'` 还是 `'X'` 格式）。

3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。

   小数点后的数码位数由精度决定，默认为 6。

4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。

   小数点前后的有效数码位数由精度决定，默认为 6。

5. 如果精度为 `N`，输出将截短为 `N` 个字符。

6. `b'%s'` 已弃用，但在 3.x 系列中将不会被移除。

7. `b'%r'` 已弃用，但在 3.x 系列中将不会被移除。

8. 参见 [**PEP 237**](https://www.python.org/dev/peps/pep-0237)。

注解

 

此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。

参见

 

[**PEP 461**](https://www.python.org/dev/peps/pep-0461) - 为 bytes 和 bytearray 添加 % 格式化

*3.5 新版功能.*



### 内存视图

[`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview) 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 [缓冲区协议](https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects) 而无需进行拷贝。

- *class* `memoryview`(*obj*)

  创建一个引用 *obj* 的 [`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview)。 *obj* 必须支持缓冲区协议。 支持缓冲区协议的内置对象包括 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 和 [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray)。[`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview) 具有 *元素* 的概念，即由原始对象 *obj* 所处理的基本内存单元。 对于许多简单类型例如 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 和 [`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray) 来说，一个元素就是一个字节，但是其他的类型例如 [`array.array`](https://docs.python.org/zh-cn/3/library/array.html#array.array) 可能有更大的元素。`len(view)` 与 [`tolist`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.tolist) 的长度相等。 如果 `view.ndim = 0`，则其长度为 1。 如果 `view.ndim = 1`，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 [`itemsize`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.itemsize) 属性可向你给出单个元素所占的字节数。[`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview) 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:>>>`>>> v = memoryview(b'abcefg') >>> v[1] 98 >>> v[-1] 103 >>> v[1:4] <memory at 0x7f3ddc9f4350> >>> bytes(v[1:4]) b'bce' `如果 [`format`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.format) 是一个来自于 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 *元素*。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 *ndim* 个整数构成的元素进行索引，*ndim* 即其维度。 零维内存视图可以使用空元组进行索引。这里是一个使用非字节格式的例子:>>>`>>> import array >>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444]) >>> m = memoryview(a) >>> m[0] -11111111 >>> m[-1] 44444444 >>> m[::2].tolist() [-11111111, -33333333] `如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:>>>`>>> data = bytearray(b'abcefg') >>> v = memoryview(data) >>> v.readonly False >>> v[0] = ord(b'z') >>> data bytearray(b'zbcefg') >>> v[1:4] = b'123' >>> data bytearray(b'z123fg') >>> v[2:3] = b'spam' Traceback (most recent call last):  File "<stdin>", line 1, in <module> ValueError: memoryview assignment: lvalue and rvalue have different structures >>> v[2:6] = b'spam' >>> data bytearray(b'z1spam') `由带有格式符号 'B', 'b' 或 'c' 的可哈希（只读）类型构成的一维内存视图同样是可哈希的。 哈希定义为 `hash(m) == hash(m.tobytes())`:>>>`>>> v = memoryview(b'abcefg') >>> hash(v) == hash(b'abcefg') True >>> hash(v[2:4]) == hash(b'ce') True >>> hash(v[::-2]) == hash(b'abcefg'[::-2]) True `*在 3.3 版更改:* 一维内存视图现在可以被切片。 带有格式符号 'B', 'b' 或 'c' 的一维内存视图现在是可哈希的。*在 3.4 版更改:* 内存视图现在会自动注册为 [`collections.abc.Sequence`](https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence)*在 3.5 版更改:* 内存视图现在可使用整数元组进行索引。[`memoryview`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview) 具有以下一些方法：`__eq__`(*exporter*)memoryview 与 [**PEP 3118**](https://www.python.org/dev/peps/pep-3118) 中的导出器这两者如果形状相同，并且如果当使用 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。对于 [`tolist()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.tolist) 当前所支持的 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 格式字符串子集，如果 `v.tolist() == w.tolist()` 则 `v` 和 `w` 相等:>>>`>>> import array >>> a = array.array('I', [1, 2, 3, 4, 5]) >>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0]) >>> c = array.array('b', [5, 3, 1]) >>> x = memoryview(a) >>> y = memoryview(b) >>> x == a == y == b True >>> x.tolist() == a.tolist() == y.tolist() == b.tolist() True >>> z = y[::-2] >>> z == c True >>> z.tolist() == c.tolist() True `如果两边的格式字符串都不被 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 模块所支持，则两对象比较结果总是不相等（即使格式字符串和缓冲区内容相同）:>>>`>>> from ctypes import BigEndianStructure, c_long >>> class BEPoint(BigEndianStructure): ...     _fields_ = [("x", c_long), ("y", c_long)] ... >>> point = BEPoint(100, 200) >>> a = memoryview(point) >>> b = memoryview(point) >>> a == point False >>> a == b False `请注意，与浮点数的情况一样，对于内存视图对象来说，`v is w` 也 *并不* 意味着 `v == w`。*在 3.3 版更改:* 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结构。`tobytes`(*order=None*)将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 [`bytes`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes) 构造器。>>>`>>> m = memoryview(b"abc") >>> m.tobytes() b'abc' >>> bytes(m) b'abc' `对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。 [`tobytes()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.tobytes) 支持所有格式字符串，不符合 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 模块语法的那些也包括在内。*3.8 新版功能:* *order* 可以为 {'C', 'F', 'A'}。 当 *order* 为 'C' 或 'F' 时，原始数组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，'A' 会返回物理内存的精确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先被转换为 C 形式。 *order=None* 与 *order='C'* 是相同的。`hex`([*sep*[, *bytes_per_sep*]])返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。>>>`>>> m = memoryview(b"abc") >>> m.hex() '616263' `*3.5 新版功能.**在 3.8 版更改:* 与 [`bytes.hex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.hex) 相似， [`memoryview.hex()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.hex) 现在支持可选的 *sep* 和 *bytes_per_sep* 参数以在十六进制输出的字节之间插入分隔符。`tolist`()将缓冲区内的数据以一个元素列表的形式返回。>>>`>>> memoryview(b'abc').tolist() [97, 98, 99] >>> import array >>> a = array.array('d', [1.1, 2.2, 3.3]) >>> m = memoryview(a) >>> m.tolist() [1.1, 2.2, 3.3] `*在 3.3 版更改:* [`tolist()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.tolist) 现在支持 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 模块语法中的所有单字符原生格式以及多维表示形式。`toreadonly`()返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。>>>`>>> m = memoryview(bytearray(b'abc')) >>> mm = m.toreadonly() >>> mm.tolist() [89, 98, 99] >>> mm[0] = 42 Traceback (most recent call last):  File "<stdin>", line 1, in <module> TypeError: cannot modify read-only memory >>> m[0] = 43 >>> mm.tolist() [43, 98, 99] `*3.8 新版功能.*`release`()释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动作（例如，[`bytearray`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray) 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽早去除这些限制（并释放任何多余的资源）。在此方法被调用后，任何对视图的进一步操作将引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError) ([`release()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.release) 本身除外，它可以被多次调用):>>>`>>> m = memoryview(b'abc') >>> m.release() >>> m[0] Traceback (most recent call last):  File "<stdin>", line 1, in <module> ValueError: operation forbidden on released memoryview object `使用 `with` 语句，可以通过上下文管理协议达到类似的效果:>>>`>>> with memoryview(b'abc') as m: ...     m[0] ... 97 >>> m[0] Traceback (most recent call last):  File "<stdin>", line 1, in <module> ValueError: operation forbidden on released memoryview object `*3.2 新版功能.*`cast`(*format*[, *shape*])将内存视图转化为新的格式或形状。 *shape* 默认为 `[byte_length//new_itemsize]`，这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复制。 支持的转化有 1D -> C-[contiguous](https://docs.python.org/zh-cn/3/glossary.html#term-contiguous) 和 C-contiguous -> 1D。目标格式仅限于 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 语法中的单一元素原生格式。 其中一种格式必须为字节格式 ('B', 'b' 或 'c')。 结果的字节长度必须与原始长度相同。将 1D/long 转换为 1D/unsigned bytes:>>>`>>> import array >>> a = array.array('l', [1,2,3]) >>> x = memoryview(a) >>> x.format 'l' >>> x.itemsize 8 >>> len(x) 3 >>> x.nbytes 24 >>> y = x.cast('B') >>> y.format 'B' >>> y.itemsize 1 >>> len(y) 24 >>> y.nbytes 24 `将 1D/unsigned bytes 转换为 1D/char:>>>`>>> b = bytearray(b'zyz') >>> x = memoryview(b) >>> x[0] = b'a' Traceback (most recent call last):  File "<stdin>", line 1, in <module> ValueError: memoryview: invalid value for format "B" >>> y = x.cast('c') >>> y[0] = b'a' >>> b bytearray(b'ayz') `将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char:>>>`>>> import struct >>> buf = struct.pack("i"*12, *list(range(12))) >>> x = memoryview(buf) >>> y = x.cast('i', shape=[2,2,3]) >>> y.tolist() [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]] >>> y.format 'i' >>> y.itemsize 4 >>> len(y) 2 >>> y.nbytes 48 >>> z = y.cast('b') >>> z.format 'b' >>> z.itemsize 1 >>> len(z) 48 >>> z.nbytes 48 `将 1D/unsigned long 转换为 2D/unsigned long:>>>`>>> buf = struct.pack("L"*6, *list(range(6))) >>> x = memoryview(buf) >>> y = x.cast('L', shape=[2,3]) >>> len(y) 2 >>> y.nbytes 48 >>> y.tolist() [[0, 1, 2], [3, 4, 5]] `*3.3 新版功能.**在 3.5 版更改:* 当转换为字节视图时，源格式将不再受限。还存在一些可用的只读属性：`obj`内存视图的下层对象:>>>`>>> b  = bytearray(b'xyz') >>> m = memoryview(b) >>> m.obj is b True `*3.3 新版功能.*`nbytes``nbytes == product(shape) * itemsize == len(m.tobytes())`。 这是数组在连续表示时将会占用的空间总字节数。 它不一定等于 `len(m)`:>>>`>>> import array >>> a = array.array('i', [1,2,3,4,5]) >>> m = memoryview(a) >>> len(m) 5 >>> m.nbytes 20 >>> y = m[::2] >>> len(y) 3 >>> y.nbytes 12 >>> len(y.tobytes()) 12 `多维数组:>>>`>>> import struct >>> buf = struct.pack("d"*12, *[1.5*x for x in range(12)]) >>> x = memoryview(buf) >>> y = x.cast('d', shape=[3,4]) >>> y.tolist() [[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]] >>> len(y) 3 >>> y.nbytes 96 `*3.3 新版功能.*`readonly`一个表明内存是否只读的布尔值。`format`一个字符串，包含视图中每个元素的格式（表示为 [`struct`](https://docs.python.org/zh-cn/3/library/struct.html#module-struct) 模块样式）。 内存视图可以从具有任意格式字符串的导出器创建，但某些方法 (例如 [`tolist()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.tolist)) 仅限于原生的单元素格式。*在 3.3 版更改:* 格式 `'B'` 现在会按照 struct 模块语法来处理。 这意味着 `memoryview(b'abc')[0] == b'abc'[0] == 97`。`itemsize`memoryview 中每个元素以字节表示的大小:>>>`>>> import array, struct >>> m = memoryview(array.array('H', [32000, 32001, 32002])) >>> m.itemsize 2 >>> m[0] 32000 >>> struct.calcsize('H') == m.itemsize True ``ndim`一个整数，表示内存所代表的多维数组具有多少个维度。`shape`一个整数元组，通过 [`ndim`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.ndim) 的长度值给出内存所代表的 N 维数组的形状。*在 3.3 版更改:* 当 ndim = 0 时值为空元组而不再为 `None`。`strides`一个整数元组，通过 [`ndim`](https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview.ndim) 的长度给出以字节表示的大小，以便访问数组中每个维度上的每个元素。*在 3.3 版更改:* 当 ndim = 0 时值为空元组而不再为 `None`。`suboffsets`供 PIL 风格的数组内部使用。 该值仅作为参考信息。`c_contiguous`一个表明内存是否为 C-[contiguous](https://docs.python.org/zh-cn/3/glossary.html#term-contiguous) 的布尔值。*3.3 新版功能.*`f_contiguous`一个表明内存是否为 Fortran [contiguous](https://docs.python.org/zh-cn/3/glossary.html#term-contiguous) 的布尔值。*3.3 新版功能.*`contiguous`一个表明内存是否为 [contiguous](https://docs.python.org/zh-cn/3/glossary.html#term-contiguous) 的布尔值。*3.3 新版功能.*



## 集合类型 --- [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set), [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset)

*set* 对象是由具有唯一性的 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable) 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器对象请参看 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/zh-cn/3/library/stdtypes.html#list) 与 [`tuple`](https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple) 等内置类，以及 [`collections`](https://docs.python.org/zh-cn/3/library/collections.html#module-collections) 模块。）

与其他多项集一样，集合也支持 `x in set`, `len(set)` 和 `for x in set`。 作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。

目前有两种内置集合类型，[`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 和 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset)。 [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 类型是可变的 --- 其内容可以使用 `add()` 和 `remove()` 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 类型是不可变并且为 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable) --- 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。

除了可以使用 [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: `{'jack', 'sjoerd'}`。

两个类的构造器具有相同的作用方式：

- *class* `set`([*iterable*])

- *class* `frozenset`([*iterable*])

  返回一个新的 set 或 frozenset 对象，其元素来自于 *iterable*。 集合的元素必须为 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable)。 要表示由集合对象构成的集合，所有的内层集合必须为 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 对象。 如果未指定 *iterable*，则将返回一个新的空集合。集合可用多种方式来创建:使用花括号内以逗号分隔元素的方式: `{'jack', 'sjoerd'}`使用集合推导式: `{c for c in 'abracadabra' if c not in 'abc'}`使用类型构造器: `set()`, `set('foobar')`, `set(['a', 'b', 'foo'])`[`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 和 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 的实例提供以下操作：`len(s)`返回集合 *s* 中的元素数量（即 *s* 的基数）。`x in s`检测 *x* 是否为 *s* 中的成员。`x not in s`检测 *x* 是否非 *s* 中的成员。`isdisjoint`(*other*)如果集合中没有与 *other* 共有的元素则返回 `True`。 当且仅当两个集合的交集为空集合时，两者为不相交集合。`issubset`(*other*)`set <= other`检测是否集合中的每个元素都在 *other* 之中。`set < other`检测集合是否为 *other* 的真子集，即 `set <= other and set != other`。`issuperset`(*other*)`set >= other`检测是否 *other* 中的每个元素都在集合之中。`set > other`检测集合是否为 *other* 的真超集，即 `set >= other and set != other`。`union`(**others*)`set | other | ...`返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。`intersection`(**others*)`set & other & ...`返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。`difference`(**others*)`set - other - ...`返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。`symmetric_difference`(*other*)`set ^ other`返回一个新集合，其中的元素或属于原集合或属于 *other* 指定的其他集合，但不能同时属于两者。`copy`()返回原集合的浅拷贝。请注意，非运算符版本的 [`union()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.union), [`intersection()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.intersection), [`difference()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.difference)，以及 [`symmetric_difference()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.symmetric_difference), [`issubset()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.issubset) 和 [`issuperset()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.issuperset) 方法会接受任意可迭代对象作为参数。 相比之下，它们所对应的运算符版本则要求其参数为集合。 这就排除了容易出错的构造形式例如 `set('abc') & 'cbs'`，而推荐可读性更强的 `set('abc').intersection('cbs')`。[`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 和 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。[`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 的实例与 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 的实例之间基于它们的成员进行比较。 例如 `set('abc') == frozenset('abc')` 返回 `True`，`set('abc') in set([frozenset('abc')])` 也一样。子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 *所有* 比较均返回 `False`: `a<b`, `a==b`, or `a>b`。由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 [`list.sort()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#list.sort) 方法的输出并无定义。集合的元素，与字典的键类似，必须为 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable)。混合了 [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 实例与 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 的二进制位运算将返回与第一个操作数相同的类型。例如: `frozenset('ab') | set('bc')` 将返回 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 的实例。下表列出了可用于 [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 而不能用于不可变的 [`frozenset`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset) 实例的操作：`update`(**others*)`set |= other | ...`更新集合，添加来自 others 中的所有元素。`intersection_update`(**others*)`set &= other & ...`更新集合，只保留其中在所有 others 中也存在的元素。`difference_update`(**others*)`set -= other | ...`更新集合，移除其中也存在于 others 中的元素。`symmetric_difference_update`(*other*)`set ^= other`更新集合，只保留存在于集合的一方而非共同存在的元素。`add`(*elem*)将元素 *elem* 添加到集合中。`remove`(*elem*)从集合中移除元素 *elem*。 如果 *elem* 不存在于集合中则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`discard`(*elem*)如果元素 *elem* 存在于集合中则将其移除。`pop`()从集合中移除并返回任意一个元素。 如果集合为空则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`clear`()从集合中移除所有元素。请注意，非运算符版本的 [`update()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.update), [`intersection_update()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.intersection_update), [`difference_update()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.difference_update) 和 [`symmetric_difference_update()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.symmetric_difference_update) 方法将接受任意可迭代对象作为参数。请注意，[`__contains__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__), [`remove()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.remove) 和 [`discard()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset.discard) 方法的 *elem* 参数可能是一个 set。 为支持对一个等价的 frozenset 进行搜索，会根据 *elem* 临时创建一个该类型对象。



## 映射类型 --- [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict)

[mapping](https://docs.python.org/zh-cn/3/glossary.html#term-mapping) 对象会将 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable) 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 *字典*。 （关于其他容器对象请参看 [`list`](https://docs.python.org/zh-cn/3/library/stdtypes.html#list), [`set`](https://docs.python.org/zh-cn/3/library/stdtypes.html#set) 与 [`tuple`](https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple) 等内置类，以及 [`collections`](https://docs.python.org/zh-cn/3/library/collections.html#module-collections) 模块。）

字典的键 *几乎* 可以是任何值。 非 [hashable](https://docs.python.org/zh-cn/3/glossary.html#term-hashable) 的值，即包含列表、字典或其他可变类型的值（此类对象基于值而非对象标识进行比较）不可用作键。 数字类型用作键时遵循数字比较的一般规则：如果两个数值相等 (例如 `1` 和 `1.0`) 则两者可以被用来索引同一字典条目。 （但是请注意，由于计算机对于浮点数存储的只是近似值，因此将其用作字典键是不明智的。）

字典可以通过将以逗号分隔的 `键: 值` 对列表包含于花括号之内来创建，例如: `{'jack': 4098, 'sjoerd': 4127}` 或 `{4098: 'jack', 4127: 'sjoerd'}`，也可以通过 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict) 构造器来创建。

- *class* `dict`(***kwarg*)

- *class* `dict`(*mapping*, ***kwarg*)

- *class* `dict`(*iterable*, ***kwarg*)

  返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。字典可用多种方式来创建:使用花括号内以逗号分隔 `键: 值` 对的方式: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`使用字典推导式: `{}`, `{x: x ** 2 for x in range(10)}`使用类型构造器: `dict()`, `dict([('foo', 100), ('bar', 200)])`, `dict(foo=100, bar=200)`如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。 否则的话，位置参数必须为一个 [iterable](https://docs.python.org/zh-cn/3/glossary.html#term-iterable) 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。作为演示，以下示例返回的字典均等于 `{"one": 1, "two": 2, "three": 3}`:>>>`>>> a = dict(one=1, two=2, three=3) >>> b = {'one': 1, 'two': 2, 'three': 3} >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) >>> d = dict([('two', 2), ('one', 1), ('three', 3)]) >>> e = dict({'three': 3, 'one': 1, 'two': 2}) >>> f = dict({'one': 1, 'three': 3}, two=2) >>> a == b == c == d == e == f True `像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。这些是字典所支持的操作（因而自定义的映射类型也应当支持）：`list(d)`返回字典 *d* 中使用的所有键的列表。`len(d)`返回字典 *d* 中的项数。`d[key]`返回 *d* 中以 *key* 为键的项。 如果映射中不存在 *key* 则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。如果字典的子类定义了方法 [`__missing__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__) 并且 *key* 不存在，则 `d[key]` 操作将调用该方法并附带键 *key* 作为参数。 `d[key]` 随后将返回或引发 `__missing__(key)` 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 [`__missing__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__)。 如果未定义 [`__missing__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__)，则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。 [`__missing__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__missing__) 必须是一个方法；它不能是一个实例变量:>>>`>>> class Counter(dict): ...     def __missing__(self, key): ...         return 0 >>> c = Counter() >>> c['red'] 0 >>> c['red'] += 1 >>> c['red'] 1 `上面的例子显示了 [`collections.Counter`](https://docs.python.org/zh-cn/3/library/collections.html#collections.Counter) 实现的部分代码。 还有另一个不同的 `__missing__` 方法是由 [`collections.defaultdict`](https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict) 所使用的。`d[key] = value`将 `d[key]` 设为 *value*。`del d[key]`将 `d[key]` 从 *d* 中移除。 如果映射中不存在 *key* 则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`key in d`如果 *d* 中存在键 *key* 则返回 `True`，否则返回 `False`。`key not in d`等价于 `not key in d`。`iter(d)`返回以字典的键为元素的迭代器。 这是 `iter(d.keys())` 的快捷方式。`clear`()移除字典中的所有元素。`copy`()返回原字典的浅拷贝。*classmethod* `fromkeys`(*iterable*[, *value*])使用来自 *iterable* 的键创建一个新字典，并将键值设为 *value*。[`fromkeys()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.fromkeys) 是一个返回新字典的类方法。 *value* 默认为 `None`。 所有值都只引用一个单独的实例，因此让 *value* 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 [字典推导式](https://docs.python.org/zh-cn/3/reference/expressions.html#dict)。`get`(*key*[, *default*])如果 *key* 存在于字典中则返回 *key* 的值，否则返回 *default*。 如果 *default* 未给出则默认为 `None`，因而此方法绝不会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`items`()返回由字典项 (`(键, 值)` 对) 组成的一个新视图。 参见 [视图对象文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict-views)。`keys`()返回由字典键组成的一个新视图。 参见 [视图对象文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict-views)。`pop`(*key*[, *default*])如果 *key* 存在于字典中则将其移除并返回其值，否则返回 *default*。 如果 *default* 未给出且 *key* 不存在于字典中，则会引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`popitem`()从字典中移除并返回一个 `(键, 值)` 对。 键值对会按 LIFO 的顺序被返回。[`popitem()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.popitem) 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 [`popitem()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.popitem) 将引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。*在 3.7 版更改:* 现在会确保采用 LIFO 顺序。 在之前的版本中，[`popitem()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.popitem) 会返回一个任意的键/值对。`reversed(d)`返回一个逆序获取字典键的迭代器。 这是 `reversed(d.keys())` 的快捷方式。*3.8 新版功能.*`setdefault`(*key*[, *default*])如果字典存在键 *key* ，返回它的值。如果不存在，插入值为 *default* 的键 *key* ，并返回 *default* 。 *default* 默认为 `None`。`update`([*other*])使用来自 *other* 的键/值对更新字典，覆盖原有的键。 返回 `None`。[`update()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.update) 接受另一个字典对象，或者一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键/值对更新字典: `d.update(red=1, blue=2)`。`values`()返回由字典值组成的一个新视图。 参见 [视图对象文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict-views)。两个 `dict.values()` 视图之间的相等性比较将总是返回 `False`。 这在 `dict.values()` 与其自身比较时也同样适用:>>>`>>> d = {'a': 1} >>> d.values() == d.values() False ``d | other`合并 *d* 和 *other* 中的键和值来创建一个新的字典，两者必须都是字典。当 *d* 和 *other* 有相同键时， *other* 的值优先。*3.9 新版功能.*`d |= other`用 *other* 的键和值更新字典 *d* ，*other* 可以是 [mapping](https://docs.python.org/zh-cn/3/glossary.html#term-mapping) 或 [iterable](https://docs.python.org/zh-cn/3/glossary.html#term-iterable) 的键值对。当 *d* 和 *other* 有相同键时， *other* 的值优先。*3.9 新版功能.*两个字典的比较当且仅当它们具有相同的 `(键, 值)` 对时才会相等（不考虑顺序）。 排序比较 ('<', '<=', '>=', '>') 会引发 [`TypeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError)。字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。>>>`>>> d = {"one": 1, "two": 2, "three": 3, "four": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(d) ['one', 'two', 'three', 'four'] >>> list(d.values()) [1, 2, 3, 4] >>> d["one"] = 42 >>> d {'one': 42, 'two': 2, 'three': 3, 'four': 4} >>> del d["two"] >>> d["two"] = None >>> d {'one': 42, 'three': 3, 'four': 4, 'two': None} `*在 3.7 版更改:* 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。字典和字典视图都是可逆的。>>>`>>> d = {"one": 1, "two": 2, "three": 3, "four": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(reversed(d)) ['four', 'three', 'two', 'one'] >>> list(reversed(d.values())) [4, 3, 2, 1] >>> list(reversed(d.items())) [('four', 4), ('three', 3), ('two', 2), ('one', 1)] `*在 3.8 版更改:* 字典现在是可逆的。

参见

 

[`types.MappingProxyType`](https://docs.python.org/zh-cn/3/library/types.html#types.MappingProxyType) 可被用来创建一个 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict) 的只读视图。



### 字典视图对象

由 [`dict.keys()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.keys), [`dict.values()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.values) 和 [`dict.items()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.items) 所返回的对象是 *视图对象*。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。

字典视图可以被迭代以产生与其对应的数据，并支持成员检测：

- `len(dictview)`

  返回字典中的条目数。

- `iter(dictview)`

  返回字典中的键、值或项（以 `(键, 值)` 为元素的元组表示）的迭代器。键和值是按插入时的顺序进行迭代的。 这样就允许使用 [`zip()`](https://docs.python.org/zh-cn/3/library/functions.html#zip) 来创建 `(值, 键)` 对: `pairs = zip(d.values(), d.keys())`。 另一个创建相同列表的方式是 `pairs = [(v, k) for (k, v) in d.items()]`.在添加或删除字典中的条目期间对视图进行迭代可能引发 [`RuntimeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError) 或者无法完全迭代所有条目。*在 3.7 版更改:* 字典顺序会确保为插入顺序。

- `x in dictview`

  如果 *x* 是对应字典中存在的键、值或项（在最后一种情况下 *x* 应为一个 `(键, 值)` 元组） 则返回 `True`。

- `reversed(dictview)`

  返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。*在 3.8 版更改:* 字典视图现在是可逆的。

键视图类似于集合，因为其条目不重复且可哈希。 如果所有值都是可哈希的，即 `(键, 值)` 对也是不重复且可哈希的，那么条目视图也会类似于集合。 （值视图则不被视为类似于集合，因其条目通常都是有重复的。） 对于类似于集合的视图，为抽象基类 [`collections.abc.Set`](https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Set) 所定义的全部操作都是有效的 (例如 `==`, `<` 或 `^`)。

一个使用字典视图的示例:

\>>>

```
>>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
>>> keys = dishes.keys()
>>> values = dishes.values()

>>> # iteration
>>> n = 0
>>> for val in values:
...     n += val
>>> print(n)
504

>>> # keys and values are iterated over in the same order (insertion order)
>>> list(keys)
['eggs', 'sausage', 'bacon', 'spam']
>>> list(values)
[2, 1, 1, 500]

>>> # view objects are dynamic and reflect dict changes
>>> del dishes['eggs']
>>> del dishes['sausage']
>>> list(keys)
['bacon', 'spam']

>>> # set operations
>>> keys & {'eggs', 'bacon', 'salad'}
{'bacon'}
>>> keys ^ {'sausage', 'juice'}
{'juice', 'sausage', 'bacon', 'spam'}
```



## 上下文管理器类型

Python 的 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语句执行完毕时退出该上下文：

- `contextmanager.``__enter__`()

  进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句的 `as` 子句中的标识符。一个返回其自身的上下文管理器的例子是 [file object](https://docs.python.org/zh-cn/3/glossary.html#term-file-object)。 文件对象会从 __enter__() 返回其自身，以允许 [`open()`](https://docs.python.org/zh-cn/3/library/functions.html#open) 被用作 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 [`decimal.localcontext()`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.localcontext) 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 `with` 语句以外的代码。

- `contextmanager.``__exit__`(*exc_type*, *exc_val*, *exc_tb*)

  退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 `None`。自此方法返回一个真值将导致 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句屏蔽异常并继续执行紧随在 `with` 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 `with` 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 [`__exit__()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#contextmanager.__exit__) 方法是否确实已失败。

Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 请参阅 [`contextlib`](https://docs.python.org/zh-cn/3/library/contextlib.html#module-contextlib) 模块查看相关的示例。

Python 的 [generator](https://docs.python.org/zh-cn/3/glossary.html#term-generator) 和 [`contextlib.contextmanager`](https://docs.python.org/zh-cn/3/library/contextlib.html#contextlib.contextmanager) 装饰器提供了实现这些协议的便捷方式。 如果使用 [`contextlib.contextmanager`](https://docs.python.org/zh-cn/3/library/contextlib.html#contextlib.contextmanager) 装饰器来装饰一个生成器函数，它将返回一个实现了必要的 [`__enter__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__) and [`__exit__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__) 方法的上下文管理器，而不再是由未经装饰的生成器函数所产生的迭代器。

请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销相比，单个类字典查找的开销可以忽略不计。

## 字符串常量

此模块中定义的常量为：

- `string.``ascii_letters`

  下文所述 [`ascii_lowercase`](https://docs.python.org/zh-cn/3/library/string.html#string.ascii_lowercase) 和 [`ascii_uppercase`](https://docs.python.org/zh-cn/3/library/string.html#string.ascii_uppercase) 常量的拼连。 该值不依赖于语言区域。

- `string.``ascii_lowercase`

  小写字母 `'abcdefghijklmnopqrstuvwxyz'`。 该值不依赖于语言区域，不会发生改变。

- `string.``ascii_uppercase`

  大写字母 `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`。 该值不依赖于语言区域，不会发生改变。

- `string.``digits`

  字符串 `'0123456789'`。

- `string.``hexdigits`

  字符串 `'0123456789abcdefABCDEF'`。

- `string.``octdigits`

  字符串 `'01234567'`。

- `string.``punctuation`

  由在 `C` 区域设置中被视为标点符号的 ASCII 字符所组成的字符串: `!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~`.

- `string.``printable`

  由被视为可打印符号的 ASCII 字符组成的字符串。 这是 [`digits`](https://docs.python.org/zh-cn/3/library/string.html#string.digits), [`ascii_letters`](https://docs.python.org/zh-cn/3/library/string.html#string.ascii_letters), [`punctuation`](https://docs.python.org/zh-cn/3/library/string.html#string.punctuation) 和 [`whitespace`](https://docs.python.org/zh-cn/3/library/string.html#string.whitespace) 的总和。

- `string.``whitespace`

  由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。



## 自定义字符串格式化

内置的字符串类提供了通过使用 [**PEP 3101**](https://www.python.org/dev/peps/pep-3101) 所描述的 [`format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 方法进行复杂变量替换和值格式化的能力。 [`string`](https://docs.python.org/zh-cn/3/library/string.html#module-string) 模块中的 [`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 类允许你使用与内置 [`format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 方法相同的实现来创建并定制你自己的字符串格式化行为。

- *class* `string.``Formatter`

  [`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 类包含下列公有方法：`format`(*format_string*, */*, **args*, ***kwargs*)首要的 API 方法。 它接受一个格式字符串和任意一组位置和关键字参数。 它只是一个调用 [`vformat()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.vformat) 的包装器。*在 3.7 版更改:* 格式字符串参数现在是 [仅限位置参数](https://docs.python.org/zh-cn/3/glossary.html#positional-only-parameter)。`vformat`(*format_string*, *args*, *kwargs*)此函数执行实际的格式化操作。 它被公开为一个单独的函数，用于需要传入一个预定义字母作为参数，而不是使用 `*args` 和 `**kwargs` 语法将字典解包为多个单独参数并重打包的情况。 [`vformat()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.vformat) 完成将格式字符串分解为字符数据和替换字段的工作。 它会调用下文所述的几种不同方法。此外，[`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 还定义了一些旨在被子类替换的方法：`parse`(*format_string*)循环遍历 format_string 并返回一个由可迭代对象组成的元组 (*literal_text*, *field_name*, *format_spec*, *conversion*)。 它会被 [`vformat()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.vformat) 用来将字符串分解为文本字面值或替换字段。元组中的值在概念上表示一段字面文本加上一个替换字段。 如果没有字面文本（如果连续出现两个替换字段就会发生这种情况），则 *literal_text* 将是一个长度为零的字符串。 如果没有替换字段，则 *field_name*, *format_spec* 和 *conversion* 的值将为 `None`。`get_field`(*field_name*, *args*, *kwargs*)给定 *field_name* 作为 [`parse()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.parse) (见上文) 的返回值，将其转换为要格式化的对象。 返回一个元组 (obj, used_key)。 默认版本接受在 [**PEP 3101**](https://www.python.org/dev/peps/pep-3101) 所定义形式的字符串，例如 "0[name]" 或 "label.title"。 *args* 和 *kwargs* 与传给 [`vformat()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.vformat) 的一样。 返回值 *used_key* 与 [`get_value()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.get_value) 的 *key* 形参具有相同的含义。`get_value`(*key*, *args*, *kwargs*)提取给定的字段值。 *key* 参数将为整数或字符串。 如果是整数，它表示 *args* 中位置参数的索引；如果是字符串，它表示 *kwargs* 中的关键字参数名。*args* 形参会被设为 [`vformat()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.vformat) 的位置参数列表，而 *kwargs* 形参会被设为由关键字参数组成的字典。对于复合字段名称，仅会为字段名称的第一个组件调用这些函数；后续组件会通过普通属性和索引操作来进行处理。因此举例来说，字段表达式 '0.name' 将导致调用 [`get_value()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.get_value) 时附带 *key* 参数值 0。 在 [`get_value()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.get_value) 通过调用内置的 [`getattr()`](https://docs.python.org/zh-cn/3/library/functions.html#getattr) 函数返回后将会查找 `name` 属性。如果索引或关键字引用了一个不存在的项，则将引发 [`IndexError`](https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError) 或 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError)。`check_unused_args`(*used_args*, *args*, *kwargs*)在必要时实现对未使用参数进行检测。 此函数的参数是是格式字符串中实际引用的所有参数键的集合（整数表示位置参数，字符串表示名称参数），以及被传给 vformat 的 *args* 和 *kwargs* 的引用。 未使用参数的集合可以根据这些形参计算出来。 如果检测失败则 [`check_unused_args()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.check_unused_args) 应会引发一个异常。`format_field`(*value*, *format_spec*)[`format_field()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.format_field) 会简单地调用内置全局函数 [`format()`](https://docs.python.org/zh-cn/3/library/functions.html#format)。 提供该方法是为了让子类能够重载它。`convert_field`(*value*, *conversion*)使用给定的转换类型（来自 [`parse()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.parse) 方法所返回的元组）来转换（由 [`get_field()`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter.get_field) 所返回的）值。 默认版本支持 's' (str), 'r' (repr) 和 'a' (ascii) 等转换类型。



## 格式字符串语法

[`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 方法和 [`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 类共享相同的格式字符串语法（虽然对于 [`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 来说，其子类可以定义它们自己的格式字符串语法）。 具体语法与 [格式化字符串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings) 相似，但也存在区别。

格式字符串包含有以花括号 `{}` 括起来的“替换字段”。 不在花括号之内的内容被视为字面文本，会不加修改地复制到输出中。 如果你需要在字面文本中包含花括号字符，可以通过重复来转义: `{{` and `}}`。

替换字段的语法如下：

> ```
> replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"
> field_name        ::=  arg_name ("." attribute_name | "[" element_index "]")*
> arg_name          ::=  [identifier | digit+]
> attribute_name    ::=  identifier
> element_index     ::=  digit+ | index_string
> index_string      ::=  <any source character except "]"> +
> conversion        ::=  "r" | "s" | "a"
> format_spec       ::=  <described in the next section>
> ```

用不太正式的术语来描述，替换字段开头可以用一个 *field_name* 指定要对值进行格式化并取代替换字符被插入到输出结果的对象。 *field_name* 之后有可选的 *conversion* 字段，它是一个感叹号 `'!'` 加一个 *format_spec*，并以一个冒号 `':'` 打头。 这些指明了替换值的非默认格式。

另请参阅 [格式规格迷你语言](https://docs.python.org/zh-cn/3/library/string.html#formatspec) 一节。

*field_name* 本身以一个数字或关键字 *arg_name* 打头。 如果为数字，则它指向一个位置参数，而如果为关键字，则它指向一个命名关键字参数。 如果格式字符串中的数字 arg_names 为 0, 1, 2, ... 的序列，它们可以全部省略（而非部分省略），数字 0, 1, 2, ... 将会按顺序自动插入。 由于 *arg_name* 不使用引号分隔，因此无法在格式字符串中指定任意的字典键 (例如字符串 `'10'` 或 `':-]'`)。 *arg_name* 之后可以带上任意数量的索引或属性表达式。 `'.name'` 形式的表达式会使用 [`getattr()`](https://docs.python.org/zh-cn/3/library/functions.html#getattr) 选择命名属性，而 `'[index]'` 形式的表达式会使用 [`__getitem__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__) 执行索引查找。

*在 3.1 版更改:* 位置参数说明符对于 [`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 可以省略，因此 `'{} {}'.format(a, b)` 等价于 `'{0} {1}'.format(a, b)`。

*在 3.4 版更改:* 位置参数说明符对于 [`Formatter`](https://docs.python.org/zh-cn/3/library/string.html#string.Formatter) 可以省略。

一些简单的格式字符串示例

```
"First, thou shalt count to {0}"  # References first positional argument
"Bring me a {}"                   # Implicitly references the first positional argument
"From {} to {}"                   # Same as "From {0} to {1}"
"My quest is {name}"              # References keyword argument 'name'
"Weight in tons {0.weight}"       # 'weight' attribute of first positional arg
"Units destroyed: {players[0]}"   # First element of keyword argument 'players'.
```

使用 *conversion* 字段在格式化之前进行类型强制转换。 通常，格式化值的工作由值本身的 [`__format__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__format__) 方法来完成。 但是，在某些情况下最好强制将类型格式化为一个字符串，覆盖其本身的格式化定义。 通过在调用 [`__format__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__format__) 之前将值转换为字符串，可以绕过正常的格式化逻辑。

目前支持的转换旗标有三种: `'!s'` 会对值调用 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str)，`'!r'` 调用 [`repr()`](https://docs.python.org/zh-cn/3/library/functions.html#repr) 而 `'!a'` 则调用 [`ascii()`](https://docs.python.org/zh-cn/3/library/functions.html#ascii)。

几个例子：

```
"Harold's a clever {0!s}"        # Calls str() on the argument first
"Bring out the holy {name!r}"    # Calls repr() on the argument first
"More {!a}"                      # Calls ascii() on the argument first
```

*format_spec* 字段包含值应如何呈现的规格描述，例如字段宽度、对齐、填充、小数精度等细节信息。 每种值类型可以定义自己的“格式化迷你语言”或对 *format_spec* 的解读方式。

大多数内置类型都支持同样的格式化迷你语言，具体描述见下一节。

*format_spec* 字段还可以在其内部包含嵌套的替换字段。 这些嵌套的替换字段可能包括字段名称、转换旗标和格式规格描述，但是不再允许更深层的嵌套。 format_spec 内部的替换字段会在解读 *format_spec* 字符串之前先被解读。 这将允许动态地指定特定值的格式。

请参阅 [格式示例](https://docs.python.org/zh-cn/3/library/string.html#formatexamples) 一节查看相关示例。



### 格式规格迷你语言

“格式规格”在格式字符串所包含的替换字段内部使用，用于定义单个值应如何呈现 (参见 [格式字符串语法](https://docs.python.org/zh-cn/3/library/string.html#formatstrings) 和 [格式字符串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings))。 它们也可以被直接传给内置的 [`format()`](https://docs.python.org/zh-cn/3/library/functions.html#format) 函数。 每种可格式化的类型都可以自行定义如何对格式规格进行解读。

大多数内置类型都为格式规格实现了下列选项，不过某些格式化选项只被数值类型所支持。

一般约定空的格式描述将产生与在值上调用 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 相同的结果。 非空格式描述通常会修改此结果。

*标准格式说明符* 的一般形式如下：

```
format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  <any character>
align           ::=  "<" | ">" | "=" | "^"
sign            ::=  "+" | "-" | " "
width           ::=  digit+
grouping_option ::=  "_" | ","
precision       ::=  digit+
type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
```

如果指定了一个有效的 *align* 值，则可以在该值前面加一个 *fill* 字符，它可以为任意字符，如果省略则默认为空格符。 在 [格式化字符串字面值](https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings) 或在使用 [`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 方法时是无法使用花括号字面值 ("`{`" or "`}`") 作为 *fill* 字符的。 但是，通过嵌套替换字段插入花括号则是可以的。 这个限制不会影响 [`format()`](https://docs.python.org/zh-cn/3/library/functions.html#format) 函数。

各种对齐选项的含义如下：

> | 选项  | 意义                                                         |
> | :---- | :----------------------------------------------------------- |
> | `'<'` | 强制字段在可用空间内左对齐（这是大多数对象的默认值）。       |
> | `'>'` | 强制字段在可用空间内右对齐（这是数字的默认值）。             |
> | `'='` | 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 |
> | `'^'` | 强制字段在可用空间内居中。                                   |

请注意，除非定义了最小字段宽度，否则字段宽度将始终与填充它的数据大小相同，因此在这种情况下，对齐选项没有意义。

*sign* 选项仅对数字类型有效，可以是以下之一：

> | 选项  | 意义                                           |
> | :---- | :--------------------------------------------- |
> | `'+'` | 表示标志应该用于正数和负数。                   |
> | `'-'` | 表示标志应仅用于负数（这是默认行为）。         |
> | space | 表示应在正数上使用前导空格，在负数上使用减号。 |

`'#'` 选项可以让“替代形式”被用于转换。 替代形式会针对不同类型分别定义。 此选项仅对整数、浮点数和复数类型有效。 对于整数类型，当使用二进制、八进制或十六进制输出时，此选项会为输出值分别添加相应的 `'0b'`, `'0o'`, or `'0x'` 前缀。 对于浮点数和复数类型，替代形式会使得转换结果总是包含小数点符号，即使其不带小数部分。 通常只有在带有小数部分的情况下，此类转换的结果中才会出现小数点符号。 此外，对于 `'g'` 和 `'G'` 转换，末尾的零不会从结果中被移除。

`','` 选项表示使用逗号作为千位分隔符。 对于感应区域设置的分隔符，请改用 `'n'` 整数表示类型。

*在 3.1 版更改:* 添加了 `','` 选项 (另请参阅 [**PEP 378**](https://www.python.org/dev/peps/pep-0378))。

`'_'` 选项表示对浮点表示类型和整数表示类型 `'d'` 使用下划线作为千位分隔符。 对于整数表示类型 `'b'`, `'o'`, `'x'` 和 `'X'`，将为每 4 个数位插入一个下划线。 对于其他表示类型指定此选项则将导致错误。

*在 3.6 版更改:* 添加了 `'_'` 选项 (另请参阅 [**PEP 515**](https://www.python.org/dev/peps/pep-0515))。

*width* 是一个定义最小总字段宽度的十进制整数，包括任何前缀、分隔符和其他格式化字符。 如果未指定，则字段宽度将由内容确定。

当未显式给出对齐方式时，在 *width* 字段前加一个零 (`'0'`) 字段将为数字类型启用感知正负号的零填充。 这相当于设置 *fill* 字符为 `'0'` 且 *alignment* 类型为 `'='`。

*precision* 是一个十进制数字，表示对于以 `'f'` and `'F'` 格式化的浮点数值要在小数点后显示多少个数位，或者对于以 `'g'` 或 `'G'` 格式化的浮点数值要在小数点前后共显示多少个数位。 对于非数字类型，该字段表示最大字段大小 —— 换句话说就是要使用多少个来自字段内容的字符。 对于整数值则不允许使用 *precision*。

最后，*type* 确定了数据应如何呈现。

可用的字符串表示类型是：

> | 类型  | 意义                                         |
> | :---- | :------------------------------------------- |
> | `'s'` | 字符串格式。这是字符串的默认类型，可以省略。 |
> | None  | 和 `'s'` 一样。                              |

可用的整数表示类型是：

> | 类型  | 意义                                                         |
> | :---- | :----------------------------------------------------------- |
> | `'b'` | 二进制格式。 输出以 2 为基数的数字。                         |
> | `'c'` | 字符。在打印之前将整数转换为相应的unicode字符。              |
> | `'d'` | 十进制整数。 输出以 10 为基数的数字。                        |
> | `'o'` | 八进制格式。 输出以 8 为基数的数字。                         |
> | `'x'` | 十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。 |
> | `'X'` | 十六进制格式。 输出以 16 为基数的数字，使用大写字母表示 9 以上的数码。 |
> | `'n'` | 数字。 这与 `'d'` 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。 |
> | None  | 和 `'d'` 相同。                                              |

在上述的表示类型之外，整数还可以通过下列的浮点表示类型来格式化 (除了 `'n'` 和 `None`)。 当这样做时，会在格式化之前使用 [`float()`](https://docs.python.org/zh-cn/3/library/functions.html#float) 将整数转换为浮点数。

[`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 和 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 值的可用表示类型有:

> | 类型  | 意义                                                         |
> | :---- | :----------------------------------------------------------- |
> | `'e'` | 科学计数法。 对于一个给定的精度 `p`，将数字格式化为以字母 'e' 分隔系数和指数的科学计数法形式。 系数在小数点之前有一位，之后有 `p` 位，总计 `p + 1` 个有效数位。 如未指定精度，则会对 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 采用小数点之后 `6` 位精度，而对 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 则显示所有系数位。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 `#` 选项。 |
> | `'E'` | 科学计数法。 与 `'e'` 相似，不同之处在于它使用大写字母 'E' 作为分隔字符。 |
> | `'f'` | 定点表示法。 对于一个给定的精度 `p`，将数字格式化为在小数点之后恰好有 `p` 位的小数形式。 如未指定精度，则会对 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 采用小数点之后 `6` 位精度，而对 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 则使用大到足够显示所有系数位的精度。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 `#` 选项。 |
> | `'F'` | 定点表示。 与 `'f'` 相似，但会将 `nan` 转为 `NAN` 并将 `inf` 转为 `INF`。 |
> | `'g'` | 常规格式。 对于给定精度 `p >= 1`，这会将数值舍入到 `p` 个有效数位，再将结果以定点表示法或科学计数法进行格式化，具体取决于其值的大小。 精度 `0` 会被视为等价于精度 `1`。准确的规则如下：假设使用表示类型 `'e'` 和精度 `p-1` 进行格式化的结果具有指数值 `exp`。 那么如果 `m <= exp < p`，其中 `m` 以 -4 表示浮点值而以 -6 表示 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 值，该数字将使用类型 `'f'` 和精度 `p-1-exp` 进行格式化。 否则的话，该数字将使用表示类型 `'e'` 和精度 `p-1` 进行格式化。 在两种情况下，都会从有效数字中移除无意义的末尾零，如果小数点之后没有余下数字则小数点也会被移除，除非使用了 `'#'` 选项。如未指定精度，会对 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 采用 `6` 个有效数位的精度。 对于 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal)，结果的系数会沿用原值的系数数位；对于绝对值小于 `1e-6` 的值以及最小有效数位的位值大于 1 的数值将会使用科学计数法，在其他情况下则会使用定点表示法。正负无穷，正负零和 nan 会分别被格式化为 `inf`, `-inf`, `0`, `-0` 和 `nan`，无论精度如何设定。 |
> | `'G'` | 常规格式。 类似于 `'g'`，不同之处在于当数值非常大时会切换为 `'E'`。 无穷与 NaN 也会表示为大写形式。 |
> | `'n'` | 数字。 这与 `'g'` 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。 |
> | `'%'` | 百分比。 将数字乘以 100 并显示为定点 (`'f'`) 格式，后面带一个百分号。 |
> | None  | 对于 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 来说这类似于 `'g'`，不同之处在于当使用定点表示法时，小数点之后将至少显示一位。 所用的精度会大到足以精确表示给定的值。对于 [`Decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal) 来说这相当于 `'g'` 或 `'G'`，具体取决于当前 decimal 上下文的 `context.capitals` 值。总体效果是将 [`str()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str) 的输出匹配为其他格式化因子所调整出的样子。 |



### 格式示例

本节包含 [`str.format()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format) 语法的示例以及与旧式 `%` 格式化的比较。

该语法在大多数情况下与旧式的 `%` 格式化类似，只是增加了 `{}` 和 `:` 来取代 `%`。 例如，，`'%03.2f'` 可以被改写为 `'{:03.2f}'`。

新的格式语法还支持新增的不同选项，将在以下示例中说明。

按位置访问参数:

\>>>

```
>>> '{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'
>>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only
'a, b, c'
>>> '{2}, {1}, {0}'.format('a', 'b', 'c')
'c, b, a'
>>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
'c, b, a'
>>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
'abracadabra'
```

按名称访问参数:

\>>>

```
>>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
'Coordinates: 37.24N, -115.81W'
>>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
>>> 'Coordinates: {latitude}, {longitude}'.format(**coord)
'Coordinates: 37.24N, -115.81W'
```

访问参数的属性:

\>>>

```
>>> c = 3-5j
>>> ('The complex number {0} is formed from the real part {0.real} '
...  'and the imaginary part {0.imag}.').format(c)
'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'
>>> class Point:
...     def __init__(self, x, y):
...         self.x, self.y = x, y
...     def __str__(self):
...         return 'Point({self.x}, {self.y})'.format(self=self)
...
>>> str(Point(4, 2))
'Point(4, 2)'
```

访问参数的项:

\>>>

```
>>> coord = (3, 5)
>>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
'X: 3;  Y: 5'
```

替代 `%s` 和 `%r`:

\>>>

```
>>> "repr() shows quotes: {!r}; str() doesn't: {!s}".format('test1', 'test2')
"repr() shows quotes: 'test1'; str() doesn't: test2"
```

对齐文本以及指定宽度:

\>>>

```
>>> '{:<30}'.format('left aligned')
'left aligned                  '
>>> '{:>30}'.format('right aligned')
'                 right aligned'
>>> '{:^30}'.format('centered')
'           centered           '
>>> '{:*^30}'.format('centered')  # use '*' as a fill char
'***********centered***********'
```

替代 `%+f`, `%-f` 和 `% f` 以及指定正负号:

\>>>

```
>>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
'+3.140000; -3.140000'
>>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
' 3.140000; -3.140000'
>>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
'3.140000; -3.140000'
```

替代 `%x` 和 `%o` 以及转换基于不同进位制的值:

\>>>

```
>>> # format also supports binary numbers
>>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
>>> # with 0x, 0o, or 0b as prefix:
>>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'
```

使用逗号作为千位分隔符:

\>>>

```
>>> '{:,}'.format(1234567890)
'1,234,567,890'
```

表示为百分数:

\>>>

```
>>> points = 19
>>> total = 22
>>> 'Correct answers: {:.2%}'.format(points/total)
'Correct answers: 86.36%'
```

使用特定类型的专属格式化:

\>>>

```
>>> import datetime
>>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)
>>> '{:%Y-%m-%d %H:%M:%S}'.format(d)
'2010-07-04 12:15:58'
```

嵌套参数以及更复杂的示例:

\>>>

```
>>> for align, text in zip('<^>', ['left', 'center', 'right']):
...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)
...
'left<<<<<<<<<<<<'
'^^^^^center^^^^^'
'>>>>>>>>>>>right'
>>>
>>> octets = [192, 168, 0, 1]
>>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)
'C0A80001'
>>> int(_, 16)
3232235521
>>>
>>> width = 5
>>> for num in range(5,12): 
...     for base in 'dXob':
...         print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
...     print()
...
    5     5     5   101
    6     6     6   110
    7     7     7   111
    8     8    10  1000
    9     9    11  1001
   10     A    12  1010
   11     B    13  1011
```



## 模板字符串

模板字符串提供了由 [**PEP 292**](https://www.python.org/dev/peps/pep-0292) 所描述的更简便的字符串替换方式。 模板字符串的一个主要用例是文本国际化 (i18n)，因为在此场景下，更简单的语法和功能使得文本翻译过程比使用 Python 的其他内置字符串格式化工具更为方便。 作为基于模板字符串构建以实现 i18n 的库的一个示例，请参看 [flufl.i18n](http://flufli18n.readthedocs.io/en/latest/) 包。

模板字符串支持基于 `$` 的替换，使用以下规则：

- `$$` 为转义符号；它会被替换为单个的 `$`。
- `$identifier` 为替换占位符，它会匹配一个名为 `"identifier"` 的映射键。 在默认情况下，`"identifier"` 限制为任意 ASCII 字母数字（包括下划线）组成的字符串，不区分大小写，以下划线或 ASCII 字母开头。 在 `$` 字符之后的第一个非标识符字符将表明占位符的终结。
- `${identifier}` 等价于 `$identifier`。 当占位符之后紧跟着有效的但又不是占位符一部分的标识符字符时需要使用，例如 `"${noun}ification"`。

在字符串的其他位置出现 `$` 将导致引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。

[`string`](https://docs.python.org/zh-cn/3/library/string.html#module-string) 模块提供了实现这些规则的 [`Template`](https://docs.python.org/zh-cn/3/library/string.html#string.Template) 类。 [`Template`](https://docs.python.org/zh-cn/3/library/string.html#string.Template) 有下列方法：

- *class* `string.``Template`(*template*)

  该构造器接受一个参数作为模板字符串。`substitute`(*mapping={}*, */*, ***kwds*)执行模板替换，返回一个新字符串。 *mapping* 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 *mapping* 和 *kwds* 并且存在重复时，则以 *kwds* 中的占位符为优先。`safe_substitute`(*mapping={}*, */*, ***kwds*)类似于 [`substitute()`](https://docs.python.org/zh-cn/3/library/string.html#string.Template.substitute)，不同之处是如果有占位符未在 *mapping* 和 *kwds* 中找到，不是引发 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError) 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 [`substitute()`](https://docs.python.org/zh-cn/3/library/string.html#string.Template.substitute) 的差异是任何在其他情况下出现的 `$` 将简单地返回 `$` 而不是引发 [`ValueError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError)。此方法被认为“安全”，因为虽然仍有可能发生其他异常，但它总是尝试返回可用的字符串而不是引发一个异常。 从另一方面来说，[`safe_substitute()`](https://docs.python.org/zh-cn/3/library/string.html#string.Template.safe_substitute) 也可能根本算不上安全，因为它将静默地忽略错误格式的模板，例如包含多余的分隔符、不成对的花括号或不是合法 Python 标识符的占位符等等。[`Template`](https://docs.python.org/zh-cn/3/library/string.html#string.Template) 的实例还提供一个公有数据属性：`template`这是作为构造器的 *template* 参数被传入的对象。 一般来说，你不应该修改它，但并不强制要求只读访问。

以下是一个如何使用模版的示例：

\>>>

```
>>> from string import Template
>>> s = Template('$who likes $what')
>>> s.substitute(who='tim', what='kung pao')
'tim likes kung pao'
>>> d = dict(who='tim')
>>> Template('Give $who $100').substitute(d)
Traceback (most recent call last):
...
ValueError: Invalid placeholder in string: line 1, col 11
>>> Template('$who likes $what').substitute(d)
Traceback (most recent call last):
...
KeyError: 'what'
>>> Template('$who likes $what').safe_substitute(d)
'tim likes $what'
```

进阶用法：你可以派生 [`Template`](https://docs.python.org/zh-cn/3/library/string.html#string.Template) 的子类来自定义占位符语法、分隔符，或用于解析模板字符串的整个正则表达式。 为此目的，你可以重载这些类属性：

- *delimiter* -- 这是用来表示占位符的起始的分隔符的字符串字面值。 默认值为 `$`。 请注意此参数 *不能* 为正则表达式，因为其实现将在必要时对此字符串调用 [`re.escape()`](https://docs.python.org/zh-cn/3/library/re.html#re.escape)。 还要注意你不能在创建类之后改变此分隔符（例如在子类的类命名空间中必须设置不同的分隔符）。

- *idpattern* -- 这是用来描述不带花括号的占位符的模式的正则表达式。 默认值为正则表达式 `(?a:[_a-z][_a-z0-9]*)`。 如果给出了此属性并且 *braceidpattern* 为 `None` 则此模式也将作用于带花括号的占位符。

  注解

   

  由于默认的 *flags* 为 `re.IGNORECASE`，模式 `[a-z]` 可以匹配某些非 ASCII 字符。 因此我们在这里使用了局部旗标 `a`。

  *在 3.7 版更改:* *braceidpattern* 可被用来定义对花括号内部和外部进行区分的模式。

- *braceidpattern* -- 此属性类似于 *idpattern* 但是用来描述带花括号的占位符的模式。 默认值 `None` 意味着回退到 *idpattern* (即在花括号内部和外部使用相同的模式)。 如果给出此属性，这将允许你为带花括号和不带花括号的占位符定义不同的模式。

  *3.7 新版功能.*

- *flags* -- 将在编译用于识别替换内容的正则表达式被应用的正则表达式旗标。 默认值为 `re.IGNORECASE`。 请注意 `re.VERBOSE` 总是会被加为旗标，因此自定义的 *idpattern* 必须遵循详细正则表达式的约定。

  *3.2 新版功能.*

作为另一种选项，你可以通过重载类属性 *pattern* 来提供整个正则表达式模式。 如果你这样做，该值必须为一个具有四个命名捕获组的正则表达式对象。 这些捕获组对应于上面已经给出的规则，以及无效占位符的规则：

- *escaped* -- 这个组匹配转义序列，在默认模式中即 `$$`。
- *named* -- 这个组匹配不带花括号的占位符名称；它不应当包含捕获组中的分隔符。
- *braced* -- 这个组匹配带有花括号的占位符名称；它不应当包含捕获组中的分隔符或者花括号。
- *invalid* -- 这个组匹配任何其他分隔符模式（通常为单个分隔符），并且它应当出现在正则表达式的末尾。

## 辅助函数

- `string.``capwords`(*s*, *sep=None*)

  使用 [`str.split()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.split) 将参数拆分为单词，使用 [`str.capitalize()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.capitalize) 将单词转为大写形式，使用 [`str.join()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.join) 将大写的单词进行拼接。 如果可选的第二个参数 *sep* 被省略或为 `None`，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 *sep* 会被用来拆分和拼接单词。